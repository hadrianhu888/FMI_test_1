var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"fmi_setup_test","ref":false,"files":[{"name":"fmi_setup_test.c","type":"source","group":"model","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * fmi_setup_test.c\r\n *\r\n * Code generation for model \"fmi_setup_test\".\r\n *\r\n * Model version              : 1.51\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Fri May 27 18:27:52 2022\r\n *\r\n * Target selection: grtfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-32 (Windows32)\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"fmi_setup_test_capi.h\"\r\n#include \"fmi_setup_test.h\"\r\n#include \"fmi_setup_test_private.h\"\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU_fmi_setup_test_T fmi_setup_test_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_fmi_setup_test_T fmi_setup_test_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_fmi_setup_test_T fmi_setup_test_M_;\r\nRT_MODEL_fmi_setup_test_T *const fmi_setup_test_M = &fmi_setup_test_M_;\r\n\r\n/* Model step function */\r\nvoid fmi_setup_test_step(void)\r\n{\r\n  /* Outport: '<Root>/output' incorporates:\r\n   *  Inport: '<Root>/input'\r\n   *  Inport: '<Root>/input1'\r\n   *  Inport: '<Root>/input2'\r\n   *  Inport: '<Root>/input3'\r\n   *  Inport: '<Root>/input4'\r\n   *  Product: '<Root>/Divide'\r\n   *  Sum: '<Root>/Add'\r\n   *  Sum: '<Root>/Add1'\r\n   *  Sum: '<Root>/Add2'\r\n   */\r\n  fmi_setup_test_Y.output = (((fmi_setup_test_U.input / fmi_setup_test_U.input1\r\n    + fmi_setup_test_U.input4) + fmi_setup_test_U.input1) +\r\n    (fmi_setup_test_U.input2 + fmi_setup_test_U.input3)) +\r\n    fmi_setup_test_U.input3;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid fmi_setup_test_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)fmi_setup_test_M, 0,\r\n                sizeof(RT_MODEL_fmi_setup_test_T));\r\n\r\n  /* external inputs */\r\n  (void)memset(&fmi_setup_test_U, 0, sizeof(ExtU_fmi_setup_test_T));\r\n\r\n  /* external outputs */\r\n  fmi_setup_test_Y.output = 0.0F;\r\n\r\n  /* Initialize DataMapInfo substructure containing ModelMap for C API */\r\n  fmi_setup_test_InitializeDataMapInfo();\r\n}\r\n\r\n/* Model terminate function */\r\nvoid fmi_setup_test_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n"},{"name":"fmi_setup_test.h","type":"header","group":"model","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * fmi_setup_test.h\r\n *\r\n * Code generation for model \"fmi_setup_test\".\r\n *\r\n * Model version              : 1.51\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Fri May 27 18:27:52 2022\r\n *\r\n * Target selection: grtfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-32 (Windows32)\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_fmi_setup_test_h_\r\n#define RTW_HEADER_fmi_setup_test_h_\r\n#include <string.h>\r\n#include \"rtw_modelmap.h\"\r\n#ifndef fmi_setup_test_COMMON_INCLUDES_\r\n#define fmi_setup_test_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#endif                                 /* fmi_setup_test_COMMON_INCLUDES_ */\r\n\r\n#include \"fmi_setup_test_types.h\"\r\n\r\n/* Shared type includes */\r\n#include \"multiword_types.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetDataMapInfo\r\n#define rtmGetDataMapInfo(rtm)         ((rtm)->DataMapInfo)\r\n#endif\r\n\r\n#ifndef rtmSetDataMapInfo\r\n#define rtmSetDataMapInfo(rtm, val)    ((rtm)->DataMapInfo = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real32_T input;                      /* '<Root>/input' */\r\n  real32_T input1;                     /* '<Root>/input1' */\r\n  real32_T input2;                     /* '<Root>/input2' */\r\n  real32_T input3;                     /* '<Root>/input3' */\r\n  real32_T input4;                     /* '<Root>/input4' */\r\n} ExtU_fmi_setup_test_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real32_T output;                     /* '<Root>/output' */\r\n} ExtY_fmi_setup_test_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_fmi_setup_test_T {\r\n  const char_T *errorStatus;\r\n\r\n  /*\r\n   * DataMapInfo:\r\n   * The following substructure contains information regarding\r\n   * structures generated in the model's C API.\r\n   */\r\n  struct {\r\n    rtwCAPI_ModelMappingInfo mmi;\r\n  } DataMapInfo;\r\n};\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU_fmi_setup_test_T fmi_setup_test_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_fmi_setup_test_T fmi_setup_test_Y;\r\n\r\n/* Model entry point functions */\r\nextern void fmi_setup_test_initialize(void);\r\nextern void fmi_setup_test_step(void);\r\nextern void fmi_setup_test_terminate(void);\r\n\r\n/* Function to get C API Model Mapping Static Info */\r\nextern const rtwCAPI_ModelMappingStaticInfo*\r\n  fmi_setup_test_GetCAPIStaticMap(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_fmi_setup_test_T *const fmi_setup_test_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'fmi_setup_test'\r\n * '<S1>'   : 'fmi_setup_test/powergui'\r\n */\r\n#endif                                 /* RTW_HEADER_fmi_setup_test_h_ */\r\n"},{"name":"fmi_setup_test_private.h","type":"header","group":"model","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * fmi_setup_test_private.h\r\n *\r\n * Code generation for model \"fmi_setup_test\".\r\n *\r\n * Model version              : 1.51\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Fri May 27 18:27:52 2022\r\n *\r\n * Target selection: grtfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-32 (Windows32)\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_fmi_setup_test_private_h_\r\n#define RTW_HEADER_fmi_setup_test_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"builtin_typeid_types.h\"\r\n#include \"multiword_types.h\"\r\n#endif                                /* RTW_HEADER_fmi_setup_test_private_h_ */\r\n"},{"name":"fmi_setup_test_types.h","type":"header","group":"model","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * fmi_setup_test_types.h\r\n *\r\n * Code generation for model \"fmi_setup_test\".\r\n *\r\n * Model version              : 1.51\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Fri May 27 18:27:52 2022\r\n *\r\n * Target selection: grtfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-32 (Windows32)\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_fmi_setup_test_types_h_\r\n#define RTW_HEADER_fmi_setup_test_types_h_\r\n\r\n/* Model Code Variants */\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_fmi_setup_test_T RT_MODEL_fmi_setup_test_T;\r\n\r\n#endif                                 /* RTW_HEADER_fmi_setup_test_types_h_ */\r\n"},{"name":"builtin_typeid_types.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * builtin_typeid_types.h\r\n *\r\n * Code generation for model \"fmi_setup_test\".\r\n *\r\n * Model version              : 1.51\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Fri May 27 18:27:52 2022\r\n *\r\n * Target selection: grtfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-32 (Windows32)\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef BUILTIN_TYPEID_TYPES_H\r\n#define BUILTIN_TYPEID_TYPES_H\r\n#include \"rtwtypes.h\"\r\n#ifndef BUILTIN_TYPEID_TYPES\r\n#define BUILTIN_TYPEID_TYPES\r\n\r\n/* Enumeration of built-in data types */\r\ntypedef enum {\r\n  SS_DOUBLE = 0,                       /* real_T    */\r\n  SS_SINGLE = 1,                       /* real32_T  */\r\n  SS_INT8 = 2,                         /* int8_T    */\r\n  SS_UINT8 = 3,                        /* uint8_T   */\r\n  SS_INT16 = 4,                        /* int16_T   */\r\n  SS_UINT16 = 5,                       /* uint16_T  */\r\n  SS_INT32 = 6,                        /* int32_T   */\r\n  SS_UINT32 = 7,                       /* uint32_T  */\r\n  SS_BOOLEAN = 8                       /* boolean_T */\r\n} BuiltInDTypeId;\r\n\r\n#define SS_NUM_BUILT_IN_DTYPE          ((int_T)SS_BOOLEAN+1)\r\n\r\n/* Enumeration for MAT-file logging code */\r\ntypedef int_T DTypeId;\r\n\r\n#endif                                 /* BUILTIN_TYPEID_TYPES */\r\n#endif                                 /* BUILTIN_TYPEID_TYPES_H */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Code generation for model \"fmi_setup_test\".\r\n *\r\n * Model version              : 1.51\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Fri May 27 18:27:52 2022\r\n *\r\n * Target selection: grtfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-32 (Windows32)\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long long longlong_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Code generation for model \"fmi_setup_test\".\r\n *\r\n * Model version              : 1.51\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Fri May 27 18:27:52 2022\r\n *\r\n * Target selection: grtfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-32 (Windows32)\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n#ifndef INT64_T\r\n#define INT64_T\r\n\r\ntypedef long long int64_T;\r\n\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#endif\r\n\r\n#ifndef UINT64_T\r\n#define UINT64_T\r\n\r\ntypedef unsigned long long uint64_T;\r\n\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n#endif\r\n\r\n/*===========================================================================*\r\n * Additional complex number type definitions                                           *\r\n *===========================================================================*/\r\n#ifndef CINT64_T\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#endif\r\n\r\n#ifndef CUINT64_T\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"fmi_setup_test_capi.c","type":"source","group":"interface","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * fmi_setup_test_capi.c\r\n *\r\n * Code generation for model \"fmi_setup_test\".\r\n *\r\n * Model version              : 1.51\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Fri May 27 18:27:52 2022\r\n *\r\n * Target selection: grtfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-32 (Windows32)\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtw_capi.h\"\r\n#ifdef HOST_CAPI_BUILD\r\n#include \"fmi_setup_test_capi_host.h\"\r\n#define sizeof(s)                      ((size_t)(0xFFFF))\r\n#undef rt_offsetof\r\n#define rt_offsetof(s,el)              ((uint16_T)(0xFFFF))\r\n#define TARGET_CONST\r\n#define TARGET_STRING(s)               (s)\r\n#else                                  /* HOST_CAPI_BUILD */\r\n#include \"builtin_typeid_types.h\"\r\n#include \"fmi_setup_test.h\"\r\n#include \"fmi_setup_test_capi.h\"\r\n#include \"fmi_setup_test_private.h\"\r\n#ifdef LIGHT_WEIGHT_CAPI\r\n#define TARGET_CONST\r\n#define TARGET_STRING(s)               ((NULL))\r\n#else\r\n#define TARGET_CONST                   const\r\n#define TARGET_STRING(s)               (s)\r\n#endif\r\n#endif                                 /* HOST_CAPI_BUILD */\r\n\r\n/* Block output signal information */\r\nstatic const rtwCAPI_Signals rtBlockSignals[] = {\r\n  /* addrMapIndex, sysNum, blockPath,\r\n   * signalName, portNumber, dataTypeIndex, dimIndex, fxpIndex, sTimeIndex\r\n   */\r\n  {\r\n    0, 0, (NULL), (NULL), 0, 0, 0, 0, 0\r\n  }\r\n};\r\n\r\nstatic const rtwCAPI_BlockParameters rtBlockParameters[] = {\r\n  /* addrMapIndex, blockPath,\r\n   * paramName, dataTypeIndex, dimIndex, fixPtIdx\r\n   */\r\n  {\r\n    0, (NULL), (NULL), 0, 0, 0\r\n  }\r\n};\r\n\r\n/* Block states information */\r\nstatic const rtwCAPI_States rtBlockStates[] = {\r\n  /* addrMapIndex, contStateStartIndex, blockPath,\r\n   * stateName, pathAlias, dWorkIndex, dataTypeIndex, dimIndex,\r\n   * fixPtIdx, sTimeIndex, isContinuous, hierInfoIdx, flatElemIdx\r\n   */\r\n  {\r\n    0, -1, (NULL), (NULL), (NULL), 0, 0, 0, 0, 0, 0, -1, 0\r\n  }\r\n};\r\n\r\n/* Root Inputs information */\r\nstatic const rtwCAPI_Signals rtRootInputs[] = {\r\n  /* addrMapIndex, sysNum, blockPath,\r\n   * signalName, portNumber, dataTypeIndex, dimIndex, fxpIndex, sTimeIndex\r\n   */\r\n  { 0, 0, TARGET_STRING(\"fmi_setup_test/input\"),\r\n    TARGET_STRING(\"\"), 1, 0, 0, 0, 0 },\r\n\r\n  { 1, 0, TARGET_STRING(\"fmi_setup_test/input1\"),\r\n    TARGET_STRING(\"\"), 2, 0, 0, 0, 0 },\r\n\r\n  { 2, 0, TARGET_STRING(\"fmi_setup_test/input2\"),\r\n    TARGET_STRING(\"\"), 3, 0, 0, 0, 0 },\r\n\r\n  { 3, 0, TARGET_STRING(\"fmi_setup_test/input3\"),\r\n    TARGET_STRING(\"\"), 4, 0, 0, 0, 0 },\r\n\r\n  { 4, 0, TARGET_STRING(\"fmi_setup_test/input4\"),\r\n    TARGET_STRING(\"\"), 5, 0, 0, 0, 0 },\r\n\r\n  {\r\n    0, 0, (NULL), (NULL), 0, 0, 0, 0, 0\r\n  }\r\n};\r\n\r\n/* Root Outputs information */\r\nstatic const rtwCAPI_Signals rtRootOutputs[] = {\r\n  /* addrMapIndex, sysNum, blockPath,\r\n   * signalName, portNumber, dataTypeIndex, dimIndex, fxpIndex, sTimeIndex\r\n   */\r\n  { 5, 0, TARGET_STRING(\"fmi_setup_test/output\"),\r\n    TARGET_STRING(\"\"), 1, 0, 0, 0, 0 },\r\n\r\n  {\r\n    0, 0, (NULL), (NULL), 0, 0, 0, 0, 0\r\n  }\r\n};\r\n\r\n/* Tunable variable parameters */\r\nstatic const rtwCAPI_ModelParameters rtModelParameters[] = {\r\n  /* addrMapIndex, varName, dataTypeIndex, dimIndex, fixPtIndex */\r\n  { 0, (NULL), 0, 0, 0 }\r\n};\r\n\r\n#ifndef HOST_CAPI_BUILD\r\n\r\n/* Declare Data Addresses statically */\r\nstatic void* rtDataAddrMap[] = {\r\n  &fmi_setup_test_U.input,             /* 0: Root Input */\r\n  &fmi_setup_test_U.input1,            /* 1: Root Input */\r\n  &fmi_setup_test_U.input2,            /* 2: Root Input */\r\n  &fmi_setup_test_U.input3,            /* 3: Root Input */\r\n  &fmi_setup_test_U.input4,            /* 4: Root Input */\r\n  &fmi_setup_test_Y.output,            /* 5: Root Output */\r\n};\r\n\r\n/* Declare Data Run-Time Dimension Buffer Addresses statically */\r\nstatic int32_T* rtVarDimsAddrMap[] = {\r\n  (NULL)\r\n};\r\n\r\n#endif\r\n\r\n/* Data Type Map - use dataTypeMapIndex to access this structure */\r\nstatic TARGET_CONST rtwCAPI_DataTypeMap rtDataTypeMap[] = {\r\n  /* cName, mwName, numElements, elemMapIndex, dataSize, slDataId, *\r\n   * isComplex, isPointer, enumStorageType */\r\n  { \"float\", \"real32_T\", 0, 0, sizeof(real32_T), (uint8_T)SS_SINGLE, 0, 0, 0 }\r\n};\r\n\r\n#ifdef HOST_CAPI_BUILD\r\n#undef sizeof\r\n#endif\r\n\r\n/* Structure Element Map - use elemMapIndex to access this structure */\r\nstatic TARGET_CONST rtwCAPI_ElementMap rtElementMap[] = {\r\n  /* elementName, elementOffset, dataTypeIndex, dimIndex, fxpIndex */\r\n  { (NULL), 0, 0, 0, 0 },\r\n};\r\n\r\n/* Dimension Map - use dimensionMapIndex to access elements of ths structure*/\r\nstatic const rtwCAPI_DimensionMap rtDimensionMap[] = {\r\n  /* dataOrientation, dimArrayIndex, numDims, vardimsIndex */\r\n  { rtwCAPI_SCALAR, 0, 2, 0 }\r\n};\r\n\r\n/* Dimension Array- use dimArrayIndex to access elements of this array */\r\nstatic const uint_T rtDimensionArray[] = {\r\n  1,                                   /* 0 */\r\n  1                                    /* 1 */\r\n};\r\n\r\n/* C-API stores floating point values in an array. The elements of this  *\r\n * are unique. This ensures that values which are shared across the model*\r\n * are stored in the most efficient way. These values are referenced by  *\r\n *           - rtwCAPI_FixPtMap.fracSlopePtr,                            *\r\n *           - rtwCAPI_FixPtMap.biasPtr,                                 *\r\n *           - rtwCAPI_SampleTimeMap.samplePeriodPtr,                    *\r\n *           - rtwCAPI_SampleTimeMap.sampleOffsetPtr                     */\r\nstatic const real_T rtcapiStoredFloats[] = {\r\n  0.2, 0.0\r\n};\r\n\r\n/* Fixed Point Map */\r\nstatic const rtwCAPI_FixPtMap rtFixPtMap[] = {\r\n  /* fracSlopePtr, biasPtr, scaleType, wordLength, exponent, isSigned */\r\n  { (NULL), (NULL), rtwCAPI_FIX_RESERVED, 0, 0, (boolean_T)0 },\r\n};\r\n\r\n/* Sample Time Map - use sTimeIndex to access elements of ths structure */\r\nstatic const rtwCAPI_SampleTimeMap rtSampleTimeMap[] = {\r\n  /* samplePeriodPtr, sampleOffsetPtr, tid, samplingMode */\r\n  { (const void *) &rtcapiStoredFloats[0], (const void *) &rtcapiStoredFloats[1],\r\n    (int8_T)0, (uint8_T)0 }\r\n};\r\n\r\nstatic rtwCAPI_ModelMappingStaticInfo mmiStatic = {\r\n  /* Signals:{signals, numSignals,\r\n   *           rootInputs, numRootInputs,\r\n   *           rootOutputs, numRootOutputs},\r\n   * Params: {blockParameters, numBlockParameters,\r\n   *          modelParameters, numModelParameters},\r\n   * States: {states, numStates},\r\n   * Maps:   {dataTypeMap, dimensionMap, fixPtMap,\r\n   *          elementMap, sampleTimeMap, dimensionArray},\r\n   * TargetType: targetType\r\n   */\r\n  { rtBlockSignals, 0,\r\n    rtRootInputs, 5,\r\n    rtRootOutputs, 1 },\r\n\r\n  { rtBlockParameters, 0,\r\n    rtModelParameters, 0 },\r\n\r\n  { rtBlockStates, 0 },\r\n\r\n  { rtDataTypeMap, rtDimensionMap, rtFixPtMap,\r\n    rtElementMap, rtSampleTimeMap, rtDimensionArray },\r\n  \"float\",\r\n\r\n  { 2866308450U,\r\n    2113094523U,\r\n    2982929260U,\r\n    598764584U },\r\n  (NULL), 0,\r\n  (boolean_T)0\r\n};\r\n\r\n/* Function to get C API Model Mapping Static Info */\r\nconst rtwCAPI_ModelMappingStaticInfo*\r\n  fmi_setup_test_GetCAPIStaticMap(void)\r\n{\r\n  return &mmiStatic;\r\n}\r\n\r\n/* Cache pointers into DataMapInfo substructure of RTModel */\r\n#ifndef HOST_CAPI_BUILD\r\n\r\nvoid fmi_setup_test_InitializeDataMapInfo(void)\r\n{\r\n  /* Set C-API version */\r\n  rtwCAPI_SetVersion(fmi_setup_test_M->DataMapInfo.mmi, 1);\r\n\r\n  /* Cache static C-API data into the Real-time Model Data structure */\r\n  rtwCAPI_SetStaticMap(fmi_setup_test_M->DataMapInfo.mmi, &mmiStatic);\r\n\r\n  /* Cache static C-API logging data into the Real-time Model Data structure */\r\n  rtwCAPI_SetLoggingStaticMap(fmi_setup_test_M->DataMapInfo.mmi, (NULL));\r\n\r\n  /* Cache C-API Data Addresses into the Real-Time Model Data structure */\r\n  rtwCAPI_SetDataAddressMap(fmi_setup_test_M->DataMapInfo.mmi, rtDataAddrMap);\r\n\r\n  /* Cache C-API Data Run-Time Dimension Buffer Addresses into the Real-Time Model Data structure */\r\n  rtwCAPI_SetVarDimsAddressMap(fmi_setup_test_M->DataMapInfo.mmi,\r\n    rtVarDimsAddrMap);\r\n\r\n  /* Cache the instance C-API logging pointer */\r\n  rtwCAPI_SetInstanceLoggingInfo(fmi_setup_test_M->DataMapInfo.mmi, (NULL));\r\n\r\n  /* Set reference to submodels */\r\n  rtwCAPI_SetChildMMIArray(fmi_setup_test_M->DataMapInfo.mmi, (NULL));\r\n  rtwCAPI_SetChildMMIArrayLen(fmi_setup_test_M->DataMapInfo.mmi, 0);\r\n}\r\n\r\n#else                                  /* HOST_CAPI_BUILD */\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  void fmi_setup_test_host_InitializeDataMapInfo\r\n    (fmi_setup_test_host_DataMapInfo_T *dataMap, const char *path)\r\n  {\r\n    /* Set C-API version */\r\n    rtwCAPI_SetVersion(dataMap->mmi, 1);\r\n\r\n    /* Cache static C-API data into the Real-time Model Data structure */\r\n    rtwCAPI_SetStaticMap(dataMap->mmi, &mmiStatic);\r\n\r\n    /* host data address map is NULL */\r\n    rtwCAPI_SetDataAddressMap(dataMap->mmi, (NULL));\r\n\r\n    /* host vardims address map is NULL */\r\n    rtwCAPI_SetVarDimsAddressMap(dataMap->mmi, (NULL));\r\n\r\n    /* Set Instance specific path */\r\n    rtwCAPI_SetPath(dataMap->mmi, path);\r\n    rtwCAPI_SetFullPath(dataMap->mmi, (NULL));\r\n\r\n    /* Set reference to submodels */\r\n    rtwCAPI_SetChildMMIArray(dataMap->mmi, (NULL));\r\n    rtwCAPI_SetChildMMIArrayLen(dataMap->mmi, 0);\r\n  }\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n#endif                                 /* HOST_CAPI_BUILD */\r\n\r\n/* EOF: fmi_setup_test_capi.c */\r\n"},{"name":"fmi_setup_test_capi.h","type":"header","group":"interface","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * fmi_setup_test_capi.h\r\n *\r\n * Code generation for model \"fmi_setup_test\".\r\n *\r\n * Model version              : 1.51\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Fri May 27 18:27:52 2022\r\n *\r\n * Target selection: grtfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-32 (Windows32)\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_fmi_setup_test_capi_h_\r\n#define RTW_HEADER_fmi_setup_test_capi_h_\r\n#include \"fmi_setup_test.h\"\r\n\r\nextern void fmi_setup_test_InitializeDataMapInfo(void);\r\n\r\n#endif                                 /* RTW_HEADER_fmi_setup_test_capi_h_ */\r\n\r\n/* EOF: fmi_setup_test_capi.h */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Code generation for model \"fmi_setup_test\".\r\n *\r\n * Model version              : 1.51\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Fri May 27 18:27:52 2022\r\n *\r\n * Target selection: grtfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-32 (Windows32)\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n\r\n/*\r\n *  Includes the appropriate headers when we are using rtModel\r\n */\r\n#include \"fmi_setup_test.h\"\r\n#define GRTINTERFACE                   0\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"},{"name":"CMakeCCompilerId.c","type":"source","group":"other","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw\\CMakeFiles\\3.22.2\\CompilerIdC","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n# error \"A C++ compiler has been selected for C.\"\r\n#endif\r\n\r\n#if defined(__18CXX)\r\n# define ID_VOID_MAIN\r\n#endif\r\n#if defined(__CLASSIC_C__)\r\n/* cv-qualifiers did not exist in K&R C */\r\n# define const\r\n# define volatile\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# define COMPILER_ID \"OpenWatcom\"\r\n   /* __WATCOMC__ = VVRP + 1100 */\r\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__SUNPRO_C)\r\n# define COMPILER_ID \"SunPro\"\r\n# if __SUNPRO_C >= 0x5100\r\n   /* __SUNPRO_C = 0xVRRP */\r\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>12)\r\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xFF)\r\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)\r\n# else\r\n   /* __SUNPRO_CC = 0xVRP */\r\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>8)\r\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xF)\r\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)\r\n# endif\r\n\r\n#elif defined(__HP_cc)\r\n# define COMPILER_ID \"HP\"\r\n  /* __HP_cc = VVRRPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__HP_cc/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__HP_cc/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__HP_cc     % 100)\r\n\r\n#elif defined(__DECC)\r\n# define COMPILER_ID \"Compaq\"\r\n  /* __DECC_VER = VVRRTPPPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__DECC_VER/10000000)\r\n# define COMPILER_VERSION_MINOR DEC(__DECC_VER/100000  % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__DECC_VER         % 10000)\r\n\r\n#elif defined(__IBMC__) && defined(__COMPILER_VER__)\r\n# define COMPILER_ID \"zOS\"\r\n  /* __IBMC__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)\r\n\r\n#elif defined(__ibmxl__) && defined(__clang__)\r\n# define COMPILER_ID \"XLClang\"\r\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\r\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\r\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\r\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\r\n\r\n\r\n#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ >= 800\r\n# define COMPILER_ID \"XL\"\r\n  /* __IBMC__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)\r\n\r\n#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ < 800\r\n# define COMPILER_ID \"VisualAge\"\r\n  /* __IBMC__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)\r\n\r\n#elif defined(__NVCOMPILER)\r\n# define COMPILER_ID \"NVHPC\"\r\n# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)\r\n# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)\r\n# if defined(__NVCOMPILER_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__PGI)\r\n# define COMPILER_ID \"PGI\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PGIC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)\r\n# if defined(__PGIC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(_CRAYC)\r\n# define COMPILER_ID \"Cray\"\r\n# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)\r\n# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)\r\n\r\n#elif defined(__TI_COMPILER_VERSION__)\r\n# define COMPILER_ID \"TI\"\r\n  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)\r\n# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)\r\n# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)\r\n\r\n#elif defined(__CLANG_FUJITSU)\r\n# define COMPILER_ID \"FujitsuClang\"\r\n# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)\r\n# define COMPILER_VERSION_INTERNAL_STR __clang_version__\r\n\r\n\r\n#elif defined(__FUJITSU)\r\n# define COMPILER_ID \"Fujitsu\"\r\n# if defined(__FCC_version__)\r\n#   define COMPILER_VERSION __FCC_version__\r\n# elif defined(__FCC_major__)\r\n#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)\r\n#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)\r\n#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)\r\n# endif\r\n# if defined(__fcc_version)\r\n#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)\r\n# elif defined(__FCC_VERSION)\r\n#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)\r\n# endif\r\n\r\n\r\n#elif defined(__ghs__)\r\n# define COMPILER_ID \"GHS\"\r\n/* __GHS_VERSION_NUMBER = VVVVRP */\r\n# ifdef __GHS_VERSION_NUMBER\r\n# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)\r\n# endif\r\n\r\n#elif defined(__TINYC__)\r\n# define COMPILER_ID \"TinyCC\"\r\n\r\n#elif defined(__BCC__)\r\n# define COMPILER_ID \"Bruce\"\r\n\r\n#elif defined(__SCO_VERSION__)\r\n# define COMPILER_ID \"SCO\"\r\n\r\n#elif defined(__ARMCC_VERSION) && !defined(__clang__)\r\n# define COMPILER_ID \"ARMCC\"\r\n#if __ARMCC_VERSION >= 1000000\r\n  /* __ARMCC_VERSION = VRRPPPP */\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)\r\n#else\r\n  /* __ARMCC_VERSION = VRPPPP */\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)\r\n#endif\r\n\r\n\r\n#elif defined(__clang__) && defined(__apple_build_version__)\r\n# define COMPILER_ID \"AppleClang\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# define COMPILER_VERSION_MAJOR DEC(__clang_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__clang_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)\r\n\r\n#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)\r\n# define COMPILER_ID \"ARMClang\"\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION     % 10000)\r\n# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)\r\n\r\n#elif defined(__clang__)\r\n# define COMPILER_ID \"Clang\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# define COMPILER_VERSION_MAJOR DEC(__clang_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__clang_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n\r\n#elif defined(__GNUC__)\r\n# define COMPILER_ID \"GNU\"\r\n# define COMPILER_VERSION_MAJOR DEC(__GNUC__)\r\n# if defined(__GNUC_MINOR__)\r\n#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(_MSC_VER)\r\n# define COMPILER_ID \"MSVC\"\r\n  /* _MSC_VER = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# if defined(_MSC_FULL_VER)\r\n#  if _MSC_VER >= 1400\r\n    /* _MSC_FULL_VER = VVRRPPPPP */\r\n#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)\r\n#  else\r\n    /* _MSC_FULL_VER = VVRRPPPP */\r\n#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)\r\n#  endif\r\n# endif\r\n# if defined(_MSC_BUILD)\r\n#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)\r\n# endif\r\n\r\n#elif defined(__VISUALDSPVERSION__) || defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)\r\n# define COMPILER_ID \"ADSP\"\r\n#if defined(__VISUALDSPVERSION__)\r\n  /* __VISUALDSPVERSION__ = 0xVVRRPP00 */\r\n# define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24)\r\n# define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF)\r\n# define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8  & 0xFF)\r\n#endif\r\n\r\n#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)\r\n# define COMPILER_ID \"IAR\"\r\n# if defined(__VER__) && defined(__ICCARM__)\r\n#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)\r\n#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)\r\n#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)\r\n#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)\r\n# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))\r\n#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)\r\n#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))\r\n#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)\r\n#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)\r\n# endif\r\n\r\n#elif defined(__SDCC_VERSION_MAJOR) || defined(SDCC)\r\n# define COMPILER_ID \"SDCC\"\r\n# if defined(__SDCC_VERSION_MAJOR)\r\n#  define COMPILER_VERSION_MAJOR DEC(__SDCC_VERSION_MAJOR)\r\n#  define COMPILER_VERSION_MINOR DEC(__SDCC_VERSION_MINOR)\r\n#  define COMPILER_VERSION_PATCH DEC(__SDCC_VERSION_PATCH)\r\n# else\r\n  /* SDCC = VRP */\r\n#  define COMPILER_VERSION_MAJOR DEC(SDCC/100)\r\n#  define COMPILER_VERSION_MINOR DEC(SDCC/10 % 10)\r\n#  define COMPILER_VERSION_PATCH DEC(SDCC    % 10)\r\n# endif\r\n\r\n\r\n/* These compilers are either not known or too old to define an\r\n  identification macro.  Try to identify the platform and guess that\r\n  it is the native compiler.  */\r\n#elif defined(__hpux) || defined(__hpua)\r\n# define COMPILER_ID \"HP\"\r\n\r\n#else /* unknown compiler */\r\n# define COMPILER_ID \"\"\r\n#endif\r\n\r\n/* Construct the string literal in pieces to prevent the source from\r\n   getting matched.  Store it in a pointer rather than an array\r\n   because some compilers will just produce instructions to fill the\r\n   array rather than assigning a pointer to a static array.  */\r\nchar const* info_compiler = \"INFO\" \":\" \"compiler[\" COMPILER_ID \"]\";\r\n#ifdef SIMULATE_ID\r\nchar const* info_simulate = \"INFO\" \":\" \"simulate[\" SIMULATE_ID \"]\";\r\n#endif\r\n\r\n#ifdef __QNXNTO__\r\nchar const* qnxnto = \"INFO\" \":\" \"qnxnto[]\";\r\n#endif\r\n\r\n#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)\r\nchar const *info_cray = \"INFO\" \":\" \"compiler_wrapper[CrayPrgEnv]\";\r\n#endif\r\n\r\n#define STRINGIFY_HELPER(X) #X\r\n#define STRINGIFY(X) STRINGIFY_HELPER(X)\r\n\r\n/* Identify known platforms by name.  */\r\n#if defined(__linux) || defined(__linux__) || defined(linux)\r\n# define PLATFORM_ID \"Linux\"\r\n\r\n#elif defined(__MSYS__)\r\n# define PLATFORM_ID \"MSYS\"\r\n\r\n#elif defined(__CYGWIN__)\r\n# define PLATFORM_ID \"Cygwin\"\r\n\r\n#elif defined(__MINGW32__)\r\n# define PLATFORM_ID \"MinGW\"\r\n\r\n#elif defined(__APPLE__)\r\n# define PLATFORM_ID \"Darwin\"\r\n\r\n#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\r\n# define PLATFORM_ID \"Windows\"\r\n\r\n#elif defined(__FreeBSD__) || defined(__FreeBSD)\r\n# define PLATFORM_ID \"FreeBSD\"\r\n\r\n#elif defined(__NetBSD__) || defined(__NetBSD)\r\n# define PLATFORM_ID \"NetBSD\"\r\n\r\n#elif defined(__OpenBSD__) || defined(__OPENBSD)\r\n# define PLATFORM_ID \"OpenBSD\"\r\n\r\n#elif defined(__sun) || defined(sun)\r\n# define PLATFORM_ID \"SunOS\"\r\n\r\n#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)\r\n# define PLATFORM_ID \"AIX\"\r\n\r\n#elif defined(__hpux) || defined(__hpux__)\r\n# define PLATFORM_ID \"HP-UX\"\r\n\r\n#elif defined(__HAIKU__)\r\n# define PLATFORM_ID \"Haiku\"\r\n\r\n#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)\r\n# define PLATFORM_ID \"BeOS\"\r\n\r\n#elif defined(__QNX__) || defined(__QNXNTO__)\r\n# define PLATFORM_ID \"QNX\"\r\n\r\n#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)\r\n# define PLATFORM_ID \"Tru64\"\r\n\r\n#elif defined(__riscos) || defined(__riscos__)\r\n# define PLATFORM_ID \"RISCos\"\r\n\r\n#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)\r\n# define PLATFORM_ID \"SINIX\"\r\n\r\n#elif defined(__UNIX_SV__)\r\n# define PLATFORM_ID \"UNIX_SV\"\r\n\r\n#elif defined(__bsdos__)\r\n# define PLATFORM_ID \"BSDOS\"\r\n\r\n#elif defined(_MPRAS) || defined(MPRAS)\r\n# define PLATFORM_ID \"MP-RAS\"\r\n\r\n#elif defined(__osf) || defined(__osf__)\r\n# define PLATFORM_ID \"OSF1\"\r\n\r\n#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)\r\n# define PLATFORM_ID \"SCO_SV\"\r\n\r\n#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)\r\n# define PLATFORM_ID \"ULTRIX\"\r\n\r\n#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)\r\n# define PLATFORM_ID \"Xenix\"\r\n\r\n#elif defined(__WATCOMC__)\r\n# if defined(__LINUX__)\r\n#  define PLATFORM_ID \"Linux\"\r\n\r\n# elif defined(__DOS__)\r\n#  define PLATFORM_ID \"DOS\"\r\n\r\n# elif defined(__OS2__)\r\n#  define PLATFORM_ID \"OS2\"\r\n\r\n# elif defined(__WINDOWS__)\r\n#  define PLATFORM_ID \"Windows3x\"\r\n\r\n# elif defined(__VXWORKS__)\r\n#  define PLATFORM_ID \"VxWorks\"\r\n\r\n# else /* unknown platform */\r\n#  define PLATFORM_ID\r\n# endif\r\n\r\n#elif defined(__INTEGRITY)\r\n# if defined(INT_178B)\r\n#  define PLATFORM_ID \"Integrity178\"\r\n\r\n# else /* regular Integrity */\r\n#  define PLATFORM_ID \"Integrity\"\r\n# endif\r\n\r\n#else /* unknown platform */\r\n# define PLATFORM_ID\r\n\r\n#endif\r\n\r\n/* For windows compilers MSVC and Intel we can determine\r\n   the architecture of the compiler being used.  This is because\r\n   the compilers do not have flags that can change the architecture,\r\n   but rather depend on which compiler is being used\r\n*/\r\n#if defined(_WIN32) && defined(_MSC_VER)\r\n# if defined(_M_IA64)\r\n#  define ARCHITECTURE_ID \"IA64\"\r\n\r\n# elif defined(_M_ARM64EC)\r\n#  define ARCHITECTURE_ID \"ARM64EC\"\r\n\r\n# elif defined(_M_X64) || defined(_M_AMD64)\r\n#  define ARCHITECTURE_ID \"x64\"\r\n\r\n# elif defined(_M_IX86)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# elif defined(_M_ARM64)\r\n#  define ARCHITECTURE_ID \"ARM64\"\r\n\r\n# elif defined(_M_ARM)\r\n#  if _M_ARM == 4\r\n#   define ARCHITECTURE_ID \"ARMV4I\"\r\n#  elif _M_ARM == 5\r\n#   define ARCHITECTURE_ID \"ARMV5I\"\r\n#  else\r\n#   define ARCHITECTURE_ID \"ARMV\" STRINGIFY(_M_ARM)\r\n#  endif\r\n\r\n# elif defined(_M_MIPS)\r\n#  define ARCHITECTURE_ID \"MIPS\"\r\n\r\n# elif defined(_M_SH)\r\n#  define ARCHITECTURE_ID \"SHx\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# if defined(_M_I86)\r\n#  define ARCHITECTURE_ID \"I86\"\r\n\r\n# elif defined(_M_IX86)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)\r\n# if defined(__ICCARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__ICCRX__)\r\n#  define ARCHITECTURE_ID \"RX\"\r\n\r\n# elif defined(__ICCRH850__)\r\n#  define ARCHITECTURE_ID \"RH850\"\r\n\r\n# elif defined(__ICCRL78__)\r\n#  define ARCHITECTURE_ID \"RL78\"\r\n\r\n# elif defined(__ICCRISCV__)\r\n#  define ARCHITECTURE_ID \"RISCV\"\r\n\r\n# elif defined(__ICCAVR__)\r\n#  define ARCHITECTURE_ID \"AVR\"\r\n\r\n# elif defined(__ICC430__)\r\n#  define ARCHITECTURE_ID \"MSP430\"\r\n\r\n# elif defined(__ICCV850__)\r\n#  define ARCHITECTURE_ID \"V850\"\r\n\r\n# elif defined(__ICC8051__)\r\n#  define ARCHITECTURE_ID \"8051\"\r\n\r\n# elif defined(__ICCSTM8__)\r\n#  define ARCHITECTURE_ID \"STM8\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__ghs__)\r\n# if defined(__PPC64__)\r\n#  define ARCHITECTURE_ID \"PPC64\"\r\n\r\n# elif defined(__ppc__)\r\n#  define ARCHITECTURE_ID \"PPC\"\r\n\r\n# elif defined(__ARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__x86_64__)\r\n#  define ARCHITECTURE_ID \"x64\"\r\n\r\n# elif defined(__i386__)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__TI_COMPILER_VERSION__)\r\n# if defined(__TI_ARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__MSP430__)\r\n#  define ARCHITECTURE_ID \"MSP430\"\r\n\r\n# elif defined(__TMS320C28XX__)\r\n#  define ARCHITECTURE_ID \"TMS320C28x\"\r\n\r\n# elif defined(__TMS320C6X__) || defined(_TMS320C6X)\r\n#  define ARCHITECTURE_ID \"TMS320C6x\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#else\r\n#  define ARCHITECTURE_ID\r\n#endif\r\n\r\n/* Convert integer to decimal digit literals.  */\r\n#define DEC(n)                   \\\r\n  ('0' + (((n) / 10000000)%10)), \\\r\n  ('0' + (((n) / 1000000)%10)),  \\\r\n  ('0' + (((n) / 100000)%10)),   \\\r\n  ('0' + (((n) / 10000)%10)),    \\\r\n  ('0' + (((n) / 1000)%10)),     \\\r\n  ('0' + (((n) / 100)%10)),      \\\r\n  ('0' + (((n) / 10)%10)),       \\\r\n  ('0' +  ((n) % 10))\r\n\r\n/* Convert integer to hex digit literals.  */\r\n#define HEX(n)             \\\r\n  ('0' + ((n)>>28 & 0xF)), \\\r\n  ('0' + ((n)>>24 & 0xF)), \\\r\n  ('0' + ((n)>>20 & 0xF)), \\\r\n  ('0' + ((n)>>16 & 0xF)), \\\r\n  ('0' + ((n)>>12 & 0xF)), \\\r\n  ('0' + ((n)>>8  & 0xF)), \\\r\n  ('0' + ((n)>>4  & 0xF)), \\\r\n  ('0' + ((n)     & 0xF))\r\n\r\n/* Construct a string literal encoding the version number. */\r\n#ifdef COMPILER_VERSION\r\nchar const* info_version = \"INFO\" \":\" \"compiler_version[\" COMPILER_VERSION \"]\";\r\n\r\n/* Construct a string literal encoding the version number components. */\r\n#elif defined(COMPILER_VERSION_MAJOR)\r\nchar const info_version[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',\r\n  COMPILER_VERSION_MAJOR,\r\n# ifdef COMPILER_VERSION_MINOR\r\n  '.', COMPILER_VERSION_MINOR,\r\n#  ifdef COMPILER_VERSION_PATCH\r\n   '.', COMPILER_VERSION_PATCH,\r\n#   ifdef COMPILER_VERSION_TWEAK\r\n    '.', COMPILER_VERSION_TWEAK,\r\n#   endif\r\n#  endif\r\n# endif\r\n  ']','\\0'};\r\n#endif\r\n\r\n/* Construct a string literal encoding the internal version number. */\r\n#ifdef COMPILER_VERSION_INTERNAL\r\nchar const info_version_internal[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',\r\n  'i','n','t','e','r','n','a','l','[',\r\n  COMPILER_VERSION_INTERNAL,']','\\0'};\r\n#elif defined(COMPILER_VERSION_INTERNAL_STR)\r\nchar const* info_version_internal = \"INFO\" \":\" \"compiler_version_internal[\" COMPILER_VERSION_INTERNAL_STR \"]\";\r\n#endif\r\n\r\n/* Construct a string literal encoding the version number components. */\r\n#ifdef SIMULATE_VERSION_MAJOR\r\nchar const info_simulate_version[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',\r\n  SIMULATE_VERSION_MAJOR,\r\n# ifdef SIMULATE_VERSION_MINOR\r\n  '.', SIMULATE_VERSION_MINOR,\r\n#  ifdef SIMULATE_VERSION_PATCH\r\n   '.', SIMULATE_VERSION_PATCH,\r\n#   ifdef SIMULATE_VERSION_TWEAK\r\n    '.', SIMULATE_VERSION_TWEAK,\r\n#   endif\r\n#  endif\r\n# endif\r\n  ']','\\0'};\r\n#endif\r\n\r\n/* Construct the string literal in pieces to prevent the source from\r\n   getting matched.  Store it in a pointer rather than an array\r\n   because some compilers will just produce instructions to fill the\r\n   array rather than assigning a pointer to a static array.  */\r\nchar const* info_platform = \"INFO\" \":\" \"platform[\" PLATFORM_ID \"]\";\r\nchar const* info_arch = \"INFO\" \":\" \"arch[\" ARCHITECTURE_ID \"]\";\r\n\r\n\r\n\r\n#if !defined(__STDC__) && !defined(__clang__)\r\n# if defined(_MSC_VER) || defined(__ibmxl__) || defined(__IBMC__)\r\n#  define C_VERSION \"90\"\r\n# else\r\n#  define C_VERSION\r\n# endif\r\n#elif __STDC_VERSION__ > 201710L\r\n# define C_VERSION \"23\"\r\n#elif __STDC_VERSION__ >= 201710L\r\n# define C_VERSION \"17\"\r\n#elif __STDC_VERSION__ >= 201000L\r\n# define C_VERSION \"11\"\r\n#elif __STDC_VERSION__ >= 199901L\r\n# define C_VERSION \"99\"\r\n#else\r\n# define C_VERSION \"90\"\r\n#endif\r\nconst char* info_language_standard_default =\r\n  \"INFO\" \":\" \"standard_default[\" C_VERSION \"]\";\r\n\r\nconst char* info_language_extensions_default = \"INFO\" \":\" \"extensions_default[\"\r\n/* !defined(_MSC_VER) to exclude Clang's MSVC compatibility mode. */\r\n#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \\\r\n     defined(__TI_COMPILER_VERSION__)) &&                                     \\\r\n  !defined(__STRICT_ANSI__) && !defined(_MSC_VER)\r\n  \"ON\"\r\n#else\r\n  \"OFF\"\r\n#endif\r\n\"]\";\r\n\r\n/*--------------------------------------------------------------------------*/\r\n\r\n#ifdef ID_VOID_MAIN\r\nvoid main() {}\r\n#else\r\n# if defined(__CLASSIC_C__)\r\nint main(argc, argv) int argc; char *argv[];\r\n# else\r\nint main(int argc, char* argv[])\r\n# endif\r\n{\r\n  int require = 0;\r\n  require += info_compiler[argc];\r\n  require += info_platform[argc];\r\n  require += info_arch[argc];\r\n#ifdef COMPILER_VERSION_MAJOR\r\n  require += info_version[argc];\r\n#endif\r\n#ifdef COMPILER_VERSION_INTERNAL\r\n  require += info_version_internal[argc];\r\n#endif\r\n#ifdef SIMULATE_ID\r\n  require += info_simulate[argc];\r\n#endif\r\n#ifdef SIMULATE_VERSION_MAJOR\r\n  require += info_simulate_version[argc];\r\n#endif\r\n#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)\r\n  require += info_cray[argc];\r\n#endif\r\n  require += info_language_standard_default[argc];\r\n  require += info_language_extensions_default[argc];\r\n  (void)argv;\r\n  return require;\r\n}\r\n#endif\r\n"},{"name":"CMakeCXXCompilerId.cpp","type":"source","group":"other","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw\\CMakeFiles\\3.22.2\\CompilerIdCXX","tag":"","groupDisplay":"Other files","code":"/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__COMO__)\r\n# define COMPILER_ID \"Comeau\"\r\n  /* __COMO_VERSION__ = VRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\r\n\r\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# define COMPILER_ID \"OpenWatcom\"\r\n   /* __WATCOMC__ = VVRP + 1100 */\r\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__SUNPRO_CC)\r\n# define COMPILER_ID \"SunPro\"\r\n# if __SUNPRO_CC >= 0x5100\r\n   /* __SUNPRO_CC = 0xVRRP */\r\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\r\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\r\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\r\n# else\r\n   /* __SUNPRO_CC = 0xVRP */\r\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\r\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\r\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\r\n# endif\r\n\r\n#elif defined(__HP_aCC)\r\n# define COMPILER_ID \"HP\"\r\n  /* __HP_aCC = VVRRPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\r\n\r\n#elif defined(__DECCXX)\r\n# define COMPILER_ID \"Compaq\"\r\n  /* __DECCXX_VER = VVRRTPPPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\r\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\r\n\r\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\r\n# define COMPILER_ID \"zOS\"\r\n  /* __IBMCPP__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\r\n\r\n#elif defined(__ibmxl__) && defined(__clang__)\r\n# define COMPILER_ID \"XLClang\"\r\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\r\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\r\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\r\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\r\n\r\n\r\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\r\n# define COMPILER_ID \"XL\"\r\n  /* __IBMCPP__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\r\n\r\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800\r\n# define COMPILER_ID \"VisualAge\"\r\n  /* __IBMCPP__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\r\n\r\n#elif defined(__NVCOMPILER)\r\n# define COMPILER_ID \"NVHPC\"\r\n# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)\r\n# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)\r\n# if defined(__NVCOMPILER_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__PGI)\r\n# define COMPILER_ID \"PGI\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PGIC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)\r\n# if defined(__PGIC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(_CRAYC)\r\n# define COMPILER_ID \"Cray\"\r\n# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)\r\n# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)\r\n\r\n#elif defined(__TI_COMPILER_VERSION__)\r\n# define COMPILER_ID \"TI\"\r\n  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)\r\n# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)\r\n# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)\r\n\r\n#elif defined(__CLANG_FUJITSU)\r\n# define COMPILER_ID \"FujitsuClang\"\r\n# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)\r\n# define COMPILER_VERSION_INTERNAL_STR __clang_version__\r\n\r\n\r\n#elif defined(__FUJITSU)\r\n# define COMPILER_ID \"Fujitsu\"\r\n# if defined(__FCC_version__)\r\n#   define COMPILER_VERSION __FCC_version__\r\n# elif defined(__FCC_major__)\r\n#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)\r\n#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)\r\n#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)\r\n# endif\r\n# if defined(__fcc_version)\r\n#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)\r\n# elif defined(__FCC_VERSION)\r\n#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)\r\n# endif\r\n\r\n\r\n#elif defined(__ghs__)\r\n# define COMPILER_ID \"GHS\"\r\n/* __GHS_VERSION_NUMBER = VVVVRP */\r\n# ifdef __GHS_VERSION_NUMBER\r\n# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)\r\n# endif\r\n\r\n#elif defined(__SCO_VERSION__)\r\n# define COMPILER_ID \"SCO\"\r\n\r\n#elif defined(__ARMCC_VERSION) && !defined(__clang__)\r\n# define COMPILER_ID \"ARMCC\"\r\n#if __ARMCC_VERSION >= 1000000\r\n  /* __ARMCC_VERSION = VRRPPPP */\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)\r\n#else\r\n  /* __ARMCC_VERSION = VRPPPP */\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)\r\n#endif\r\n\r\n\r\n#elif defined(__clang__) && defined(__apple_build_version__)\r\n# define COMPILER_ID \"AppleClang\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# define COMPILER_VERSION_MAJOR DEC(__clang_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__clang_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)\r\n\r\n#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)\r\n# define COMPILER_ID \"ARMClang\"\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION     % 10000)\r\n# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)\r\n\r\n#elif defined(__clang__)\r\n# define COMPILER_ID \"Clang\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# define COMPILER_VERSION_MAJOR DEC(__clang_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__clang_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n\r\n#elif defined(__GNUC__) || defined(__GNUG__)\r\n# define COMPILER_ID \"GNU\"\r\n# if defined(__GNUC__)\r\n#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(_MSC_VER)\r\n# define COMPILER_ID \"MSVC\"\r\n  /* _MSC_VER = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# if defined(_MSC_FULL_VER)\r\n#  if _MSC_VER >= 1400\r\n    /* _MSC_FULL_VER = VVRRPPPPP */\r\n#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)\r\n#  else\r\n    /* _MSC_FULL_VER = VVRRPPPP */\r\n#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)\r\n#  endif\r\n# endif\r\n# if defined(_MSC_BUILD)\r\n#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)\r\n# endif\r\n\r\n#elif defined(__VISUALDSPVERSION__) || defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)\r\n# define COMPILER_ID \"ADSP\"\r\n#if defined(__VISUALDSPVERSION__)\r\n  /* __VISUALDSPVERSION__ = 0xVVRRPP00 */\r\n# define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24)\r\n# define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF)\r\n# define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8  & 0xFF)\r\n#endif\r\n\r\n#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)\r\n# define COMPILER_ID \"IAR\"\r\n# if defined(__VER__) && defined(__ICCARM__)\r\n#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)\r\n#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)\r\n#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)\r\n#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)\r\n# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))\r\n#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)\r\n#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))\r\n#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)\r\n#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)\r\n# endif\r\n\r\n\r\n/* These compilers are either not known or too old to define an\r\n  identification macro.  Try to identify the platform and guess that\r\n  it is the native compiler.  */\r\n#elif defined(__hpux) || defined(__hpua)\r\n# define COMPILER_ID \"HP\"\r\n\r\n#else /* unknown compiler */\r\n# define COMPILER_ID \"\"\r\n#endif\r\n\r\n/* Construct the string literal in pieces to prevent the source from\r\n   getting matched.  Store it in a pointer rather than an array\r\n   because some compilers will just produce instructions to fill the\r\n   array rather than assigning a pointer to a static array.  */\r\nchar const* info_compiler = \"INFO\" \":\" \"compiler[\" COMPILER_ID \"]\";\r\n#ifdef SIMULATE_ID\r\nchar const* info_simulate = \"INFO\" \":\" \"simulate[\" SIMULATE_ID \"]\";\r\n#endif\r\n\r\n#ifdef __QNXNTO__\r\nchar const* qnxnto = \"INFO\" \":\" \"qnxnto[]\";\r\n#endif\r\n\r\n#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)\r\nchar const *info_cray = \"INFO\" \":\" \"compiler_wrapper[CrayPrgEnv]\";\r\n#endif\r\n\r\n#define STRINGIFY_HELPER(X) #X\r\n#define STRINGIFY(X) STRINGIFY_HELPER(X)\r\n\r\n/* Identify known platforms by name.  */\r\n#if defined(__linux) || defined(__linux__) || defined(linux)\r\n# define PLATFORM_ID \"Linux\"\r\n\r\n#elif defined(__MSYS__)\r\n# define PLATFORM_ID \"MSYS\"\r\n\r\n#elif defined(__CYGWIN__)\r\n# define PLATFORM_ID \"Cygwin\"\r\n\r\n#elif defined(__MINGW32__)\r\n# define PLATFORM_ID \"MinGW\"\r\n\r\n#elif defined(__APPLE__)\r\n# define PLATFORM_ID \"Darwin\"\r\n\r\n#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\r\n# define PLATFORM_ID \"Windows\"\r\n\r\n#elif defined(__FreeBSD__) || defined(__FreeBSD)\r\n# define PLATFORM_ID \"FreeBSD\"\r\n\r\n#elif defined(__NetBSD__) || defined(__NetBSD)\r\n# define PLATFORM_ID \"NetBSD\"\r\n\r\n#elif defined(__OpenBSD__) || defined(__OPENBSD)\r\n# define PLATFORM_ID \"OpenBSD\"\r\n\r\n#elif defined(__sun) || defined(sun)\r\n# define PLATFORM_ID \"SunOS\"\r\n\r\n#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)\r\n# define PLATFORM_ID \"AIX\"\r\n\r\n#elif defined(__hpux) || defined(__hpux__)\r\n# define PLATFORM_ID \"HP-UX\"\r\n\r\n#elif defined(__HAIKU__)\r\n# define PLATFORM_ID \"Haiku\"\r\n\r\n#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)\r\n# define PLATFORM_ID \"BeOS\"\r\n\r\n#elif defined(__QNX__) || defined(__QNXNTO__)\r\n# define PLATFORM_ID \"QNX\"\r\n\r\n#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)\r\n# define PLATFORM_ID \"Tru64\"\r\n\r\n#elif defined(__riscos) || defined(__riscos__)\r\n# define PLATFORM_ID \"RISCos\"\r\n\r\n#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)\r\n# define PLATFORM_ID \"SINIX\"\r\n\r\n#elif defined(__UNIX_SV__)\r\n# define PLATFORM_ID \"UNIX_SV\"\r\n\r\n#elif defined(__bsdos__)\r\n# define PLATFORM_ID \"BSDOS\"\r\n\r\n#elif defined(_MPRAS) || defined(MPRAS)\r\n# define PLATFORM_ID \"MP-RAS\"\r\n\r\n#elif defined(__osf) || defined(__osf__)\r\n# define PLATFORM_ID \"OSF1\"\r\n\r\n#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)\r\n# define PLATFORM_ID \"SCO_SV\"\r\n\r\n#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)\r\n# define PLATFORM_ID \"ULTRIX\"\r\n\r\n#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)\r\n# define PLATFORM_ID \"Xenix\"\r\n\r\n#elif defined(__WATCOMC__)\r\n# if defined(__LINUX__)\r\n#  define PLATFORM_ID \"Linux\"\r\n\r\n# elif defined(__DOS__)\r\n#  define PLATFORM_ID \"DOS\"\r\n\r\n# elif defined(__OS2__)\r\n#  define PLATFORM_ID \"OS2\"\r\n\r\n# elif defined(__WINDOWS__)\r\n#  define PLATFORM_ID \"Windows3x\"\r\n\r\n# elif defined(__VXWORKS__)\r\n#  define PLATFORM_ID \"VxWorks\"\r\n\r\n# else /* unknown platform */\r\n#  define PLATFORM_ID\r\n# endif\r\n\r\n#elif defined(__INTEGRITY)\r\n# if defined(INT_178B)\r\n#  define PLATFORM_ID \"Integrity178\"\r\n\r\n# else /* regular Integrity */\r\n#  define PLATFORM_ID \"Integrity\"\r\n# endif\r\n\r\n#else /* unknown platform */\r\n# define PLATFORM_ID\r\n\r\n#endif\r\n\r\n/* For windows compilers MSVC and Intel we can determine\r\n   the architecture of the compiler being used.  This is because\r\n   the compilers do not have flags that can change the architecture,\r\n   but rather depend on which compiler is being used\r\n*/\r\n#if defined(_WIN32) && defined(_MSC_VER)\r\n# if defined(_M_IA64)\r\n#  define ARCHITECTURE_ID \"IA64\"\r\n\r\n# elif defined(_M_ARM64EC)\r\n#  define ARCHITECTURE_ID \"ARM64EC\"\r\n\r\n# elif defined(_M_X64) || defined(_M_AMD64)\r\n#  define ARCHITECTURE_ID \"x64\"\r\n\r\n# elif defined(_M_IX86)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# elif defined(_M_ARM64)\r\n#  define ARCHITECTURE_ID \"ARM64\"\r\n\r\n# elif defined(_M_ARM)\r\n#  if _M_ARM == 4\r\n#   define ARCHITECTURE_ID \"ARMV4I\"\r\n#  elif _M_ARM == 5\r\n#   define ARCHITECTURE_ID \"ARMV5I\"\r\n#  else\r\n#   define ARCHITECTURE_ID \"ARMV\" STRINGIFY(_M_ARM)\r\n#  endif\r\n\r\n# elif defined(_M_MIPS)\r\n#  define ARCHITECTURE_ID \"MIPS\"\r\n\r\n# elif defined(_M_SH)\r\n#  define ARCHITECTURE_ID \"SHx\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# if defined(_M_I86)\r\n#  define ARCHITECTURE_ID \"I86\"\r\n\r\n# elif defined(_M_IX86)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)\r\n# if defined(__ICCARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__ICCRX__)\r\n#  define ARCHITECTURE_ID \"RX\"\r\n\r\n# elif defined(__ICCRH850__)\r\n#  define ARCHITECTURE_ID \"RH850\"\r\n\r\n# elif defined(__ICCRL78__)\r\n#  define ARCHITECTURE_ID \"RL78\"\r\n\r\n# elif defined(__ICCRISCV__)\r\n#  define ARCHITECTURE_ID \"RISCV\"\r\n\r\n# elif defined(__ICCAVR__)\r\n#  define ARCHITECTURE_ID \"AVR\"\r\n\r\n# elif defined(__ICC430__)\r\n#  define ARCHITECTURE_ID \"MSP430\"\r\n\r\n# elif defined(__ICCV850__)\r\n#  define ARCHITECTURE_ID \"V850\"\r\n\r\n# elif defined(__ICC8051__)\r\n#  define ARCHITECTURE_ID \"8051\"\r\n\r\n# elif defined(__ICCSTM8__)\r\n#  define ARCHITECTURE_ID \"STM8\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__ghs__)\r\n# if defined(__PPC64__)\r\n#  define ARCHITECTURE_ID \"PPC64\"\r\n\r\n# elif defined(__ppc__)\r\n#  define ARCHITECTURE_ID \"PPC\"\r\n\r\n# elif defined(__ARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__x86_64__)\r\n#  define ARCHITECTURE_ID \"x64\"\r\n\r\n# elif defined(__i386__)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__TI_COMPILER_VERSION__)\r\n# if defined(__TI_ARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__MSP430__)\r\n#  define ARCHITECTURE_ID \"MSP430\"\r\n\r\n# elif defined(__TMS320C28XX__)\r\n#  define ARCHITECTURE_ID \"TMS320C28x\"\r\n\r\n# elif defined(__TMS320C6X__) || defined(_TMS320C6X)\r\n#  define ARCHITECTURE_ID \"TMS320C6x\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#else\r\n#  define ARCHITECTURE_ID\r\n#endif\r\n\r\n/* Convert integer to decimal digit literals.  */\r\n#define DEC(n)                   \\\r\n  ('0' + (((n) / 10000000)%10)), \\\r\n  ('0' + (((n) / 1000000)%10)),  \\\r\n  ('0' + (((n) / 100000)%10)),   \\\r\n  ('0' + (((n) / 10000)%10)),    \\\r\n  ('0' + (((n) / 1000)%10)),     \\\r\n  ('0' + (((n) / 100)%10)),      \\\r\n  ('0' + (((n) / 10)%10)),       \\\r\n  ('0' +  ((n) % 10))\r\n\r\n/* Convert integer to hex digit literals.  */\r\n#define HEX(n)             \\\r\n  ('0' + ((n)>>28 & 0xF)), \\\r\n  ('0' + ((n)>>24 & 0xF)), \\\r\n  ('0' + ((n)>>20 & 0xF)), \\\r\n  ('0' + ((n)>>16 & 0xF)), \\\r\n  ('0' + ((n)>>12 & 0xF)), \\\r\n  ('0' + ((n)>>8  & 0xF)), \\\r\n  ('0' + ((n)>>4  & 0xF)), \\\r\n  ('0' + ((n)     & 0xF))\r\n\r\n/* Construct a string literal encoding the version number. */\r\n#ifdef COMPILER_VERSION\r\nchar const* info_version = \"INFO\" \":\" \"compiler_version[\" COMPILER_VERSION \"]\";\r\n\r\n/* Construct a string literal encoding the version number components. */\r\n#elif defined(COMPILER_VERSION_MAJOR)\r\nchar const info_version[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',\r\n  COMPILER_VERSION_MAJOR,\r\n# ifdef COMPILER_VERSION_MINOR\r\n  '.', COMPILER_VERSION_MINOR,\r\n#  ifdef COMPILER_VERSION_PATCH\r\n   '.', COMPILER_VERSION_PATCH,\r\n#   ifdef COMPILER_VERSION_TWEAK\r\n    '.', COMPILER_VERSION_TWEAK,\r\n#   endif\r\n#  endif\r\n# endif\r\n  ']','\\0'};\r\n#endif\r\n\r\n/* Construct a string literal encoding the internal version number. */\r\n#ifdef COMPILER_VERSION_INTERNAL\r\nchar const info_version_internal[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',\r\n  'i','n','t','e','r','n','a','l','[',\r\n  COMPILER_VERSION_INTERNAL,']','\\0'};\r\n#elif defined(COMPILER_VERSION_INTERNAL_STR)\r\nchar const* info_version_internal = \"INFO\" \":\" \"compiler_version_internal[\" COMPILER_VERSION_INTERNAL_STR \"]\";\r\n#endif\r\n\r\n/* Construct a string literal encoding the version number components. */\r\n#ifdef SIMULATE_VERSION_MAJOR\r\nchar const info_simulate_version[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',\r\n  SIMULATE_VERSION_MAJOR,\r\n# ifdef SIMULATE_VERSION_MINOR\r\n  '.', SIMULATE_VERSION_MINOR,\r\n#  ifdef SIMULATE_VERSION_PATCH\r\n   '.', SIMULATE_VERSION_PATCH,\r\n#   ifdef SIMULATE_VERSION_TWEAK\r\n    '.', SIMULATE_VERSION_TWEAK,\r\n#   endif\r\n#  endif\r\n# endif\r\n  ']','\\0'};\r\n#endif\r\n\r\n/* Construct the string literal in pieces to prevent the source from\r\n   getting matched.  Store it in a pointer rather than an array\r\n   because some compilers will just produce instructions to fill the\r\n   array rather than assigning a pointer to a static array.  */\r\nchar const* info_platform = \"INFO\" \":\" \"platform[\" PLATFORM_ID \"]\";\r\nchar const* info_arch = \"INFO\" \":\" \"arch[\" ARCHITECTURE_ID \"]\";\r\n\r\n\r\n\r\n#if defined(__INTEL_COMPILER) && defined(_MSVC_LANG) && _MSVC_LANG < 201403L\r\n#  if defined(__INTEL_CXX11_MODE__)\r\n#    if defined(__cpp_aggregate_nsdmi)\r\n#      define CXX_STD 201402L\r\n#    else\r\n#      define CXX_STD 201103L\r\n#    endif\r\n#  else\r\n#    define CXX_STD 199711L\r\n#  endif\r\n#elif defined(_MSC_VER) && defined(_MSVC_LANG)\r\n#  define CXX_STD _MSVC_LANG\r\n#else\r\n#  define CXX_STD __cplusplus\r\n#endif\r\n\r\nconst char* info_language_standard_default = \"INFO\" \":\" \"standard_default[\"\r\n#if CXX_STD > 202002L\r\n  \"23\"\r\n#elif CXX_STD > 201703L\r\n  \"20\"\r\n#elif CXX_STD >= 201703L\r\n  \"17\"\r\n#elif CXX_STD >= 201402L\r\n  \"14\"\r\n#elif CXX_STD >= 201103L\r\n  \"11\"\r\n#else\r\n  \"98\"\r\n#endif\r\n\"]\";\r\n\r\nconst char* info_language_extensions_default = \"INFO\" \":\" \"extensions_default[\"\r\n/* !defined(_MSC_VER) to exclude Clang's MSVC compatibility mode. */\r\n#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \\\r\n     defined(__TI_COMPILER_VERSION__)) &&                                     \\\r\n  !defined(__STRICT_ANSI__) && !defined(_MSC_VER)\r\n  \"ON\"\r\n#else\r\n  \"OFF\"\r\n#endif\r\n\"]\";\r\n\r\n/*--------------------------------------------------------------------------*/\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n  int require = 0;\r\n  require += info_compiler[argc];\r\n  require += info_platform[argc];\r\n#ifdef COMPILER_VERSION_MAJOR\r\n  require += info_version[argc];\r\n#endif\r\n#ifdef COMPILER_VERSION_INTERNAL\r\n  require += info_version_internal[argc];\r\n#endif\r\n#ifdef SIMULATE_ID\r\n  require += info_simulate[argc];\r\n#endif\r\n#ifdef SIMULATE_VERSION_MAJOR\r\n  require += info_simulate_version[argc];\r\n#endif\r\n#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)\r\n  require += info_cray[argc];\r\n#endif\r\n  require += info_language_standard_default[argc];\r\n  require += info_language_extensions_default[argc];\r\n  (void)argv;\r\n  return require;\r\n}\r\n"},{"name":"fmi_setup_test_capi_host.h","type":"header","group":"other","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef RTW_HEADER_fmi_setup_test_cap_host_h__\r\n#define RTW_HEADER_fmi_setup_test_cap_host_h__\r\n#ifdef HOST_CAPI_BUILD\r\n#include \"rtw_capi.h\"\r\n#include \"rtw_modelmap.h\"\r\n\r\ntypedef struct {\r\n  rtwCAPI_ModelMappingInfo mmi;\r\n} fmi_setup_test_host_DataMapInfo_T;\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  void fmi_setup_test_host_InitializeDataMapInfo\r\n    (fmi_setup_test_host_DataMapInfo_T *dataMap, const char *path);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n#endif                                 /* HOST_CAPI_BUILD */\r\n#endif                              /* RTW_HEADER_fmi_setup_test_cap_host_h__ */\r\n\r\n/* EOF: fmi_setup_test_capi_host.h */\r\n"},{"name":"simstruc_rt.h","type":"header","group":"other","path":"F:\\GitHubRepos\\fmi_test_example\\fmi_setup_test_grt_fmi_rtw\\Temp","tag":"","groupDisplay":"Other files","code":"\r\n/* Add definitions to allow compilation without compiler options */\r\n#define RT\r\n#define USE_RTMODEL\r\n/* Copyright 1990-2020 The MathWorks, Inc. */\r\n\r\n/**\r\n * @file: simstruc.h\r\n *\r\n * @brief S-function Authoring APIs\r\n *\r\n * Abstract:\r\n *      Data structures and access methods for S-functions.\r\n *\r\n *      A Simulink model is an S-function.  The SimStruct contains all entry\r\n *      points within the S-function (e.g. mdlOutputs) as well any data\r\n *      associated with the S-function.\r\n *\r\n *      This file contains details of SimStruct (Simulink data structure)\r\n *      which is used to store attributes of the model such as pointers to\r\n *      storage vectors.\r\n *\r\n *      Multiple SimStructs are, in general, used by a model. These SimStruct's\r\n *      are arranged as a \"tree\". The \"root\" SimStruct is used by\r\n *      the Simulink model. There is one child SimStruct for each S-function\r\n *      block with in the model.\r\n *\r\n *      The SimStruct can be used in three environments:\r\n *        o With MATLAB/Simulink (MATLAB_MEX_FILE)\r\n *        o With Real-Time Workshop in non-real-time (NRT)\r\n *        o With Real-Time Workshop in real-time (RT)\r\n *\r\n * Defines:\r\n *      One of the following must be defined.\r\n *        MATLAB_MEX_FILE    - Must be defined when compiling as a MEX file,\r\n *                             otherwise must not be defined.\r\n *        NRT                - Define if creating non-real-time executable\r\n *        RT                 - Define if creating real-time executable.\r\n *\r\n *        See ENVIRONMENT MACROS section below for more info.\r\n *\r\n *      Defines which must be declared by the Real-Time Workshop\r\n *      generated model source.\r\n *        Simulink_NAME=\"name\"\r\n *        NSAMPLE_TIMES=n\r\n *\r\n *      Defines for use with the Real-Time Workshop (these are configured\r\n *\tby the template makefile, do not add directly to make command):\r\n *        MULTITASKING       - Optional (use MT for a synonym).\r\n *        NUMST=n            - Number of sample times in the root SimStruct.\r\n *        TID01EQ=1 or 0     - Optional. Only define to 1 if sample time task\r\n *                             id's 0 and 1 have equal rates.\r\n * =============================================================================\r\n */\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic push\r\n#if defined(__has_warning)\r\n#if __has_warning(\"-Wreserved-id-macro\")\r\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"\r\n#endif\r\n#endif\r\n#endif\r\n\r\n#ifndef __SIMSTRUC__\r\n#define __SIMSTRUC__\r\n\r\n#include \"simstruc_compcond.h\"\r\n#include \"simstruc_types.h\"\r\n#include \"simstruc_def.h\"\r\n#include \"simstruc_debug.h\"\r\n\r\n/** @defgroup IOPorts Input and Output Ports\r\n *  @{\r\n */\r\n/*======================================*\r\n * Input and Output Ports *\r\n *======================================*/\r\n\r\n/** @ingroup IOPorts\r\n */\r\n\r\n/** @defgroup SignalSpec Signal Specification\r\n **\r\n *  @{\r\n */\r\n\r\n/** Signal Specification **/\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n\r\n/**\r\n * @brief ssGetNumInputPorts(S)\r\n *\r\n * Get the number of input ports that an S-function block has\r\n * @param  S           SimStruct pointer\r\n * @return an int_T value indicating the number of input ports\r\n */\r\n#if !SS_SL_INTERNAL\r\n#define ssGetNumInputPorts(S) (S)->sizes.in.numInputPorts /*(int_T)*/\r\n#endif\r\n\r\n/**\r\n * @brief ssSetNumInputPorts(S, nInputPorts)\r\n *\r\n * Specify the number of input ports an S-function block has\r\n * @param  S           SimStruct pointer\r\n * @param  nInputPorts number of S-function input port\r\n * @return the Boolean value true if successful. Otherwise, returns false\r\n */\r\n#if SS_SFCN_FOR_SIM\r\n#define ssSetNumInputPorts(S, nInputPorts) \\\r\n    (*(S)->portInfo.regNumInputPortsFcn)((S)->portInfo.regNumInputPortsFcnArg, nInputPorts)\r\n\r\n#elif SS_SFCN_FOR_RTW\r\n/* RTW S-function block */\r\n#define ssSetNumInputPorts(S, nInputPorts) ((_ssSetNumInputPorts(S, nInputPorts)) >= 0)\r\n#elif SS_SL_INTERNAL || SS_RTW_INTERNAL\r\n/* Simulink or RTW model/run-time interface code */\r\n#define ssSetNumInputPorts(S, nInputPorts) ((_ssSetNumInputPorts(S, nInputPorts)) >= 0)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetNumOutputPorts(S)\r\n *\r\n * Get the number of output ports that an S-function block has\r\n * @param  S           SimStruct pointer\r\n * @return an int_T value indicating the number of output ports\r\n */\r\n#if !SS_SL_INTERNAL\r\n#define ssGetNumOutputPorts(S) (S)->sizes.out.numOutputPorts /*(int_T)*/\r\n#endif\r\n\r\n/**\r\n * @brief ssSetNumOutputPorts(S, nOutputPorts)\r\n *\r\n * Specify the number of output ports an S-function block has\r\n * @param  S           SimStruct pointer\r\n * @param  nOutputPorts number of S-function input port\r\n * @return the Boolean value true if successful. Otherwise, returns false\r\n */\r\n#if SS_SFCN_FOR_SIM\r\n#define ssSetNumOutputPorts(S, nOutputPorts) \\\r\n    (*(S)->portInfo.regNumOutputPortsFcn)((S)->portInfo.regNumOutputPortsFcnArg, nOutputPorts)\r\n#elif SS_SFCN_FOR_RTW\r\n/* RTW S-function block */\r\n#define ssSetNumOutputPorts(S, nOutputPorts) ((_ssSetNumOutputPorts(S, nOutputPorts)) >= 0)\r\n#elif SS_SL_INTERNAL || SS_RTW_INTERNAL\r\n/* Simulink or RTW model/run-time interface code */\r\n#define ssSetNumOutputPorts(S, nOutputPorts) ((_ssSetNumOutputPorts(S, nOutputPorts)) >= 0)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetInputPortDataType\r\n *\r\n * Get the data type ID of an input port\r\n * @param  S     SimStruct pointer\r\n * @param  port  input port index\r\n * @return the data type ID for the input port\r\n */\r\n#define ssGetInputPortDataType(S, port) \\\r\n    (S)->portInfo.inputs[(port)].dataTypeId /*     (DTypeId)   */\r\n\r\n/**\r\n * @brief ssSetInputPortDataType\r\n *\r\n * Set the data type ID of an input port\r\n * @param  S     SimStruct pointer\r\n * @param  port  input port index\r\n * @param  id    ID of the data type accepted by the input port\r\n * @return the data type ID specified by id. Returns -1 if id is DYNAMICALLY_TYPED\r\n */\r\n#define ssSetInputPortDataType(S, port, dTypeId) \\\r\n    ((S)->portInfo.inputs[(port)].dataTypeId = (dTypeId))\r\n\r\n\r\n/**\r\n * @brief ssGetInputPortComplexSignal\r\n *\r\n * Determine whether an input port accepts complex signals\r\n * @param S    SimStruct pointer\r\n * @param port input port index\r\n * @return COMPLEX_YES (1) if port accepts complex signals, COMPLEX_NO (0) if port does\r\n * not accept complex signals, and COMPLEX_INHERITED (-1) if port inherits its numeric\r\n * type from the port to which it is connected\r\n */\r\n#define ssGetInputPortComplexSignal(S, port) \\\r\n    (S)->portInfo.inputs[(port)].complexSignal /*   (CSignal_T)    */\r\n\r\n/**\r\n * @brief ssSetInputPortComplexSignal\r\n *\r\n * Determine whether an input port accepts complex signals\r\n * @param S    SimStruct pointer\r\n * @param port input port index\r\n * @param csig  Numeric type of the signals accepted by port. Valid values are COMPLEX_NO\r\n * (real signal), COMPLEX_YES (complex signal), and COMPLEX_INHERITED (numeric type\r\n * inherited from driving block).\r\n * @return 1 (COMPLEX_YES), 0 (COMPLEX_NO), or -1 (COMPLEX_INHERITED) depending on\r\n * the value specified by csig.\r\n */\r\n#define ssSetInputPortComplexSignal(S, port, csig) \\\r\n    (S)->portInfo.inputs[(port)].complexSignal = (csig)\r\n\r\n/**\r\n * @brief ssGetOutputPortComplexSignal\r\n *\r\n * Get the numeric type (complex or real) of an output port\r\n * @param S    SimStruct pointer\r\n * @param port Index of an output port.\r\n * @return COMPLEX_YES (1) if port accepts complex signals, COMPLEX_NO (0) if port does\r\n * not accept complex signals, and COMPLEX_INHERITED (-1) if port inherits its numeric\r\n * type from the port to which it is connected\r\n */\r\n#define ssGetOutputPortComplexSignal(S, port) \\\r\n    (S)->portInfo.outputs[(port)].complexSignal /* (CSignal_T)  */\r\n\r\n/**\r\n * @brief ssSetInputPortComplexSignal\r\n *\r\n * Set the numeric type (real or complex) of an output port\r\n * @param S    SimStruct pointer\r\n * @param port Output port index\r\n * @param csig  Numeric type of the signals accepted by port. Valid values are COMPLEX_NO\r\n * (real signal), COMPLEX_YES (complex signal), and COMPLEX_INHERITED (numeric type\r\n * inherited from driving block).\r\n * @return 1 (COMPLEX_YES), 0 (COMPLEX_NO), or -1 (COMPLEX_INHERITED) depending on\r\n * the value specified by csig.\r\n */\r\n#define ssSetOutputPortComplexSignal(S, port, val) \\\r\n    (S)->portInfo.outputs[(port)].complexSignal = (val)\r\n\r\n\r\n/**\r\n * @brief ssGetInputPortUnit\r\n *\r\n * Get unit of input port\r\n * @param  S     SimStruct pointer\r\n * @param  port  input port index\r\n * @return The unit ID of the input port specified by port. This ID is returned\r\n * from thes sRegisterUnitFromExpr method. Returns DYNAMICALLY_TYPED if the input\r\n * port inherits its unit.\r\n */\r\n#define ssGetInputPortUnit(S, port) \\\r\n    (S)->blkInfo.blkInfo2->portInfo2->inputUnits[(port)].unitId /*   (UnitId)    */\r\n\r\n/**\r\n * @brief ssSetInputPortUnit\r\n *\r\n * Specify unit for input port\r\n * @param  S     SimStruct pointer\r\n * @param  port  input port index\r\n * @param  id    ID of the unit accepted by port. This ID is returned from the\r\n * ssRegisterUnitFromExpr method\r\n * @return The unit ID specified by id. Returns -1 if id is DYNAMICALLY_TYPED\r\n */\r\n#define ssSetInputPortUnit(S, port, val) \\\r\n    (S)->blkInfo.blkInfo2->portInfo2->inputUnits[(port)].unitId = (val)\r\n\r\n#endif /* !SS_SFCN_LEVEL_1 */\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetInputPortDirectFeedThrough\r\n *\r\n * Specify the direct feedthrough status of a block's ports\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the input port whose direct feedthrough property is being set.\r\n * @param    dirFeed       Direct feedthrough status of the block specified by port.\r\n */\r\n#if !SS_DEBUG_FOR_SIM\r\n#define ssSetInputPortDirectFeedThrough(S, port, dirFeed) \\\r\n    (S)->portInfo.inputs[(port)].directFeedThrough = (dirFeed)\r\n#endif\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortDirectFeedThrough\r\n *\r\n * Determine whether a port has direct feedthrough\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the input port whose direct feedthrough property is being set.\r\n * @return   The int_T value 1 if the input port specified by the index port has direct feedthrough.\r\n * Otherwise, returns 0.\r\n */\r\n#define ssGetInputPortDirectFeedThrough(S, port) \\\r\n    (S)->portInfo.inputs[(port)].directFeedThrough /*   (int_T)       */\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortOffsetTime\r\n *\r\n * Get the offset time of an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the input port whose direct feedthrough property is required.\r\n * @return   A real_T value indicating the offset time of the input port specified by the index\r\n * inputPortIdx.\r\n */\r\n#define ssGetInputPortOffsetTime(S, port) \\\r\n    ((S)->portInfo.inputs[(port)].offsetTime) /* (real_T)      */\r\n\r\n/**\r\n * @brief ssSetInputPortOffsetTime\r\n *\r\n * Specify the offset time of an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the input port whose direct feedthrough property is being set.\r\n * @param    val           Offset time.\r\n * @return   The real_T value of the offset time passed into the macro.\r\n */\r\n#define ssSetInputPortOffsetTime(S, port, val) \\\r\n    (S)->portInfo.inputs[(port)].offsetTime = (val) /* (real_T)      */\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortRequiredContiguous\r\n *\r\n * Determine whether the signal elements entering a port must be contiguous\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the input port.\r\n * @return   An int_T (1 or 0) or boolean_T (true or false) value indicating\r\n * if the signal elements entering a port must be contiguous.\r\n */\r\n#define ssGetInputPortRequiredContiguous(S, port) \\\r\n    ((S)->portInfo.inputs[(port)].attributes.contiguity != 0)\r\n\r\n\r\n/**\r\n * @brief ssSetInputPortRequiredContiguous\r\n *\r\n * Specify that the signal elements entering a port must be contiguous\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the input port.\r\n * @param    val           True(1) if signal elements must be contiguous.\r\n */\r\n#define ssSetInputPortRequiredContiguous(S, port, val) \\\r\n    (S)->portInfo.inputs[(port)].attributes.contiguity = ((val) != 0)\r\n\r\n#endif\r\n\r\n/**\r\n * @brief ssRegisterUnitFromExpr\r\n *\r\n * Register unit from unit expression\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    expr          Function pointer corresponding to the unit expression for the unit being\r\n * registered.\r\n * @param    id            An integer whose value is the numeric unit type identifier after the\r\n * call to ssRegisterUnitFromExpr.\r\n */\r\n#if !SS_SFCN_LEVEL_1\r\n#if SS_SIM\r\ntypedef struct _ssRegisterUnitFromExprType_tag {\r\n    const char* unitExpr;\r\n    int* unitId;\r\n} ssRegisterUnitFromExprType;\r\n#define ssRegisterUnitFromExpr(S, expr, id)                                    \\\r\n    {                                                                          \\\r\n        ssRegisterUnitFromExprType _slRegisterUnitFromExprInfo;                \\\r\n        _slRegisterUnitFromExprInfo.unitExpr = (expr);                         \\\r\n        _slRegisterUnitFromExprInfo.unitId = (id);                             \\\r\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REGISTER_UNIT_FROM_EXPR, 0, \\\r\n                                        (void*)&_slRegisterUnitFromExprInfo)   \\\r\n            _ssSafelyCallGenericFcnEnd;                                        \\\r\n    }\r\n#else\r\n#define ssRegisterUnitFromExpr(S, name, id)\r\n#endif\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetOutputPortSampleTime\r\n *\r\n * Specify the sample time of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the output port whose sample time is being set.\r\n * @param    val           Sample time of the output port.\r\n * @return   The real_T value of the sample time passed into the macro.\r\n */\r\n#define ssSetOutputPortSampleTime(S, port, val) \\\r\n    (S)->portInfo.outputs[(port)].sampleTime = (val) /* (real_T)      */\r\n\r\n/**\r\n * @brief ssGetOutputPortOffsetTime\r\n *\r\n * Get the offset time of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the output port whose offset time is being set.\r\n * @return   A real_T value indicating the offset time of the output port specified by the index\r\n * outputPortIdx.\r\n */\r\n#define ssGetOutputPortOffsetTime(S, port) \\\r\n    ((S)->portInfo.outputs[(port)].offsetTime) /* (real_T)      */\r\n\r\n/**\r\n * @brief ssSetOutputPortOffsetTime\r\n *\r\n * Specify the offset time of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the output port whose offset time is being set.\r\n * @param    val           Offset time of the output port.\r\n * @return   The real_T value of the offset time passed into the macro.\r\n */\r\n#define ssSetOutputPortOffsetTime(S, port, val) \\\r\n    (S)->portInfo.outputs[(port)].offsetTime = (val) /* (real_T)      */\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortFrameData\r\n *\r\n * Determine whether a port accepts signal frames\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port.\r\n * @return   A value of type Frame_T, indicating if the input port specified by the index\r\n * port accepts signal frames.\r\n */\r\n#define ssGetInputPortFrameData(S, port) \\\r\n    CONV_BITS2INT((S)->portInfo.inputs[(port)].attributes.frameData)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetOutputPortFrameData\r\n *\r\n * Determine whether a port outputs signal frames\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port.\r\n * @return   A value of type Frame_T, indicating if the output port specified by the index port\r\n * produces signal frames.\r\n */\r\n#define ssGetOutputPortFrameData(S, port) \\\r\n    CONV_BITS2INT((S)->portInfo.outputs[(port)].attributes.frameData)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetOutputPortUnit\r\n *\r\n * Get unit of output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port.\r\n * @return   The unit ID of the output port specified by port.\r\n * Returns DYNAMICALLY_TYPED if the output port inherits its unit.\r\n */\r\n#define ssGetOutputPortUnit(S, port) \\\r\n    (S)->blkInfo.blkInfo2->portInfo2->outputUnits[(port)].unitId /*   (UnitId)    */\r\n\r\n/**\r\n * @brief ssSetOutputPortUnit\r\n *\r\n * Specify unit of output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port.\r\n * @param   val           ID of the unit accepted by port. This ID is returned from\r\n * the ssRegisterUnitFromExpr method.\r\n * @return   The unit ID specified by id. Returns -1 if id is DYNAMICALLY_TYPED.\r\n */\r\n#define ssSetOutputPortUnit(S, port, val) \\\r\n    (S)->blkInfo.blkInfo2->portInfo2->outputUnits[(port)].unitId = (val)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssAllowSignalsWithMoreThan2D\r\n *\r\n * Enable S-function to work with multidimensional signals\r\n * @param    S             SimStruct representing an S-Function block.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssAllowSignalsWithMoreThan2D(S)                                              \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ALLOW_MORE_THAN_2D_SIGS, 1, NULL) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n#else\r\n#define ssAllowSignalsWithMoreThan2D(S)\r\n#endif\r\n#endif\r\n\r\n/**\r\n * @brief ssSetOneBasedIndexInputPort\r\n *\r\n * Specify that an input port expects one-based indices\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Input port of the S-function\r\n */\r\n#if SS_SFCN && SS_SIM\r\n#define ssSetOneBasedIndexInputPort(S, pIdx)                                      \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ONE_BASED_IN_PORT, pIdx, NULL) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n#endif\r\n\r\n/**\r\n * @brief ssSetOneBasedIndexOutputPort\r\n *\r\n * Specify that an output port expects one-based indices\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Output port of the S-function\r\n */\r\n#if SS_SFCN && SS_SIM\r\n#define ssSetOneBasedIndexOutputPort(S, pIdx)                                      \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ONE_BASED_OUT_PORT, pIdx, NULL) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n#endif\r\n\r\n/**\r\n * @brief ssSetZeroBasedIndexInputPort\r\n *\r\n * Specify that an input port expects zero-based indices\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Input port of the S-function\r\n */\r\n#if SS_SFCN && SS_SIM\r\n#define ssSetZeroBasedIndexInputPort(S, pIdx)                                      \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ZERO_BASED_IN_PORT, pIdx, NULL) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n#endif\r\n\r\n/**\r\n * @brief ssSetZeroBasedIndexOutputPort\r\n *\r\n * Specify that an output port expects zero-based indices\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Output port of the S-function\r\n */\r\n#if SS_SFCN && SS_SIM\r\n#define ssSetZeroBasedIndexOutputPort(S, pIdx)                                      \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_ZERO_BASED_OUT_PORT, pIdx, NULL) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n#endif\r\n\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetInputPortIsContinuousQuantity\r\n *\r\n * Specify that an input port expects co-simulation signals that represents continuous quantities\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Input port of the S-function.\r\n * @param    val           Int or boolean value (0 or 1) that indicates if this port expects\r\n * a co-simulation signal, which is a discrete-time signal that represents a continuous quantity.\r\n */\r\n#define ssSetInputPortIsContinuousQuantity(S, port, val) \\\r\n    (S)->blkInfo.blkInfo2->portInfo2->inputCoSimAttribute[(port)].isContinuousQuantity = (val)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortIsContinuousQuantity\r\n *\r\n * Determine whether an input port expects co-simulation signals that represents continuous\r\n * quantities\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Input port of the S-function.\r\n * @return   Int or boolean value (0 or 1) that indicates if this port expects\r\n * a co-simulation signal, which is a discrete-time signal that represents a continuous quantity.\r\n */\r\n#define ssGetInputPortIsContinuousQuantity(S, port) \\\r\n    ((S)->blkInfo.blkInfo2->portInfo2->inputCoSimAttribute[(port)].isContinuousQuantity == 1U)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetOutputPortIsContinuousQuantity\r\n *\r\n * Specify that an output port generates co-simulation signals that represents continuous quantities\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Output port of the S-function.\r\n * @param    val           Int or boolean value (0 or 1) that indicates if this port generates\r\n * a co-simulation signal, which is a discrete-time signal that represents a continuous quantity.\r\n */\r\n#define ssSetOutputPortIsContinuousQuantity(S, port, val) \\\r\n    (S)->blkInfo.blkInfo2->portInfo2->outputCoSimAttribute[(port)].isContinuousQuantity = (val)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetOutputPortIsContinuousQuantity\r\n *\r\n * Determine whether an output port generates co-simulation signals that represents continuous\r\n * quantities\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Output port of the S-function.\r\n * @return   Int or boolean value (0 or 1) that indicates if this port generates\r\n * a co-simulation signal, which is a discrete-time signal that represents a continuous quantity.\r\n */\r\n#define ssGetOutputPortIsContinuousQuantity(S, port) \\\r\n    ((S)->blkInfo.blkInfo2->portInfo2->outputCoSimAttribute[(port)].isContinuousQuantity == 1U)\r\n#endif\r\n\r\n/** @} */ /* end of SignalSpec */\r\n\r\n/** @ingroup IOPorts\r\n */\r\n\r\n/** @defgroup SignalDims Signal Dimensions\r\n **\r\n *  @{\r\n */\r\n\r\n/** Signal Dimensions **/\r\n\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetInputPortDimensionInfo\r\n *\r\n * Specify information about the dimensionality of an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port.\r\n * @param    val           Structure of type DimsInfo_T that specifies the dimensionality of\r\n * the signals accepted by port.\r\n * @return   1 if successful; otherwise, 0.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssSetInputPortDimensionInfo(S, port, val)               \\\r\n    (((ssGetRegInputPortDimensionInfoFcn(S)) != NULL)           \\\r\n         ? (ssGetRegInputPortDimensionInfoFcn(S))(S, port, val) \\\r\n         : (1))\r\n#else /* RTW S-function block */\r\n#define ssSetInputPortDimensionInfo(S, port, val) (1)\r\n#endif\r\n#endif\r\n\r\n/**\r\n * @brief ssSetInputPortDimensionsMode\r\n *\r\n * Set the dimensions mode of the input port indexed by pIdx\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Index of an input port.\r\n * @param    value         Enum value corresponding to the ports dimensions mode.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssSetInputPortDimensionsMode(S, pIdx, value)                                  \\\r\n    {                                                                                 \\\r\n        DimensionsMode_T val = value;                                                 \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_INPUT_DIMS_MODE, pIdx, &val) \\\r\n            _ssSafelyCallGenericFcnEnd;                                               \\\r\n    }\r\n#else\r\n#define ssSetInputPortDimensionsMode(S, pIdx, value)\r\n#endif\r\n\r\n/**\r\n * @brief ssSetInputPortDimsSameAsOutputPortDims\r\n *\r\n * Set the dimensions of output port outIdx to be equal to the dimensions of input port inpIdx.\r\n * This method is called from mdlSetWorkWidths\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    inpIdx        Index of an input port.\r\n * @param    outIdx        Output port index.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssSetInputPortDimsSameAsOutputPortDims(S, inpIdx, outIdx)                            \\\r\n    {                                                                                        \\\r\n        int val = outIdx;                                                                    \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_INPUT_DIMS_SAMEAS_OUTPUT, (inpIdx), \\\r\n                                        (&val)) _ssSafelyCallGenericFcnEnd;                  \\\r\n    }\r\n#else\r\n#define ssSetInputPortDimsSameAsOutputPortDims(S, inpIdx, outIdx)\r\n#endif\r\n\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetInputPortMatrixDimensions\r\n *\r\n * Specify dimension information for an input port that accepts matrix signalsl.\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port\r\n * @param    val1          Row dimension of matrix signals accepted by port or DYNAMICALLY_SIZED.\r\n * @param    val2          Column dimension of matrix signals accepted by port or DYNAMICALLY_SIZED.\r\n */\r\n#if SS_SFCN_FOR_SIM\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetInputPortMatrixDimensions(S, port, val1, val2) \\\r\n    (_ssSetInputPortMatrixDimensionsSLSize(S, port, val1, val2))\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetInputPortMatrixDimensions(S, port, val1, val2) \\\r\n    (_ssSetInputPortMatrixDimensions(S, port, val1, val2))\r\n#endif\r\n#else /* RTW S-function block */\r\n#define ssSetInputPortMatrixDimensions(S, port, val1, val2) (1)\r\n#endif\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetInputPortVectorDimension\r\n *\r\n * Specify dimension information for an input port that accepts vector signals\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port\r\n * @param    val           Width of the vector or DYNAMICALLY_SIZED.\r\n */\r\n#if SS_SFCN_FOR_SIM\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetInputPortVectorDimension(S, port, val) \\\r\n    (_ssSetInputPortVectorDimensionSLSize(S, port, val))\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetInputPortVectorDimension(S, port, val) (_ssSetInputPortVectorDimension(S, port, val))\r\n#endif\r\n#else /* RTW S-function block */\r\n#define ssSetInputPortVectorDimension(S, port, val) (1)\r\n#endif\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortWidth\r\n *\r\n * Get the width of an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the port whose width is required\r\n * @return   An int_T value indicating the number of elements in the input signal.\r\n * If the number of elements is unknown, returns DYNAMICALLY_SIZED.\r\n */\r\n\r\n\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetInputPortWidth(S, port) (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].width\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetInputPortWidth(S, port) (S)->portInfo.inputs[(port)].width\r\n#endif\r\n\r\n/**\r\n * @brief ssSetInputPortWidth\r\n *\r\n * Specify the width of an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the port whose width is being set.\r\n * @param    width         Width of the input port.\r\n */\r\n\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetInputPortWidth(S, port, val) \\\r\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].width = (val)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetInputPortWidth(S, port, val) (S)->portInfo.inputs[(port)].width = (val)\r\n#endif\r\n\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssPruneNDMatrixSingletonDims\r\n *\r\n * Prune trailing singleton dimensions\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    dimsInfo      Structure of type DimsInfo_T that specifies the dimensionality of the\r\n * signals accepted by port.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssPruneNDMatrixSingletonDims(S, dimInfo)                                      \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_PRUN_TRAILING_DIMS, 0, (void*)dimInfo) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n#else\r\n#define ssPruneNDMatrixSingletonDims(S, dimInfo)\r\n#endif\r\n#endif\r\n\r\n/**\r\n * @brief ssSetCurrentOutputPortDimensions\r\n *\r\n * Set the current size corresponding to dimension dIdx of the output signal at port pIdx\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Output port index being set.\r\n * @param    dIdx          Index of dimension being set.\r\n * @param    val           Current size value to set for dimension dIdx.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssSetCurrentOutputPortDimensions(S, pIdx, _dIdx, _val)                             \\\r\n    {                                                                                      \\\r\n        struct _ssVarDimsIdxVal_tag dIdxVal;                                               \\\r\n        dIdxVal.dIdx = _dIdx;                                                              \\\r\n        dIdxVal.dVal = _val;                                                               \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_CURR_OUTPUT_DIMS, pIdx, &dIdxVal) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                    \\\r\n    }\r\n#else\r\n#define ssSetCurrentOutputPortDimensions(S, pIdx, dIdx, val) \\\r\n    _ssSetCurrentOutputPortDimensions(S, pIdx, dIdx, val)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetOutputPortDimensionInfo\r\n *\r\n * Specify information about the dimensionality of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port\r\n * @param    val           Structure of type DimsInfo_T that specifies the dimensionality of the\r\n * signals emitted by port.\r\n * @return   1 if successful; otherwise, 0.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssSetOutputPortDimensionInfo(S, port, val)               \\\r\n    (((ssGetRegOutputPortDimensionInfoFcn(S)) != NULL)           \\\r\n         ? (ssGetRegOutputPortDimensionInfoFcn(S))(S, port, val) \\\r\n         : (1))\r\n#else /* RTW S-function block */\r\n#define ssSetOutputPortDimensionInfo(S, port, val) (1)\r\n#endif\r\n#endif\r\n\r\n/**\r\n * @brief ssSetOutputPortDimensionsMode\r\n *\r\n * Set the dimensions mode of the output port indexed by pIdx\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Output port index being polled.\r\n * @param    value         Enum value corresponding to the ports dimensions mode.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssSetOutputPortDimensionsMode(S, pIdx, value)                                  \\\r\n    {                                                                                  \\\r\n        DimensionsMode_T val = value;                                                  \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_OUTPUT_DIMS_MODE, pIdx, &val) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                \\\r\n    }\r\n#else\r\n#define ssSetOutputPortDimensionsMode(S, pIdx, value)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetOutputPortMatrixDimensions\r\n *\r\n * Specify dimension information for an output port that emits matrix signals\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port.\r\n * @param    val1          Row dimension of matrix signals emitted by port or DYNAMICALLY_SIZED.\r\n * @param    val2          Column dimension of matrix signals emitted by port or DYNAMICALLY_SIZED.\r\n * @return   1 if successful; otherwise, 0.\r\n */\r\n#if SS_SFCN_FOR_SIM\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetOutputPortMatrixDimensions(S, port, val1, val2) \\\r\n    (_ssSetOutputPortMatrixDimensionsSLSize(S, port, val1, val2))\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetOutputPortMatrixDimensions(S, port, val1, val2) \\\r\n    (_ssSetOutputPortMatrixDimensions(S, port, val1, val2))\r\n#endif\r\n#else /* RTW S-function block */\r\n#define ssSetOutputPortMatrixDimensions(S, port, val1, val2) (1)\r\n#endif\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetOutputPortVectorDimension\r\n *\r\n * Specify dimension information for an output port that emits vector signals\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port.\r\n * @param    val           Width of the vector or DYNAMICALLY_SIZED.\r\n * @return   1 if successful; otherwise, 0.\r\n */\r\n#if SS_SFCN_FOR_SIM\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetOutputPortVectorDimension(S, port, val) \\\r\n    (_ssSetOutputPortVectorDimensionSLSize(S, port, val))\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetOutputPortVectorDimension(S, port, val) (_ssSetOutputPortVectorDimension(S, port, val))\r\n#endif\r\n#else /* RTW S-function block */\r\n#define ssSetOutputPortVectorDimension(S, port, val) (1)\r\n#endif\r\n#endif\r\n\r\n/**\r\n * @brief ssGetOutputPortWidth\r\n *\r\n * Get the width of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port.\r\n * @return   An int_T value indicating the width of the output port specified by the index port.\r\n */\r\n\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetOutputPortWidth(S, port) (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].width\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetOutputPortWidth(S, port) (S)->portInfo.outputs[(port)].width /*   (int_T)       */\r\n#endif\r\n/**\r\n * @brief ssSetOutputPortWidth\r\n *\r\n * Specify the width of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the output port whose width is being set.\r\n * @param    val           Width of an output port\r\n */\r\n\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetOutputPortWidth(S, port, val) \\\r\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].width = (val)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetOutputPortWidth(S, port, val) (S)->portInfo.outputs[(port)].width = (val)\r\n#endif\r\n\r\n/**\r\n * @brief ssAddOutputDimsDependencyRule\r\n *\r\n * Register a method to handle current dimensions update.\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    outIdx        Output port index\r\n * @param    ruleInfo      Structure containing the dimensions propagation method information.\r\n */\r\n#if SS_SFCN_FOR_SIM\r\n#define ssAddOutputDimsDependencyRule(S, outIdx, ruleInfo)                                       \\\r\n    {                                                                                            \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ADD_DIMS_DEPEND_RULE, (outIdx), (ruleInfo)) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                          \\\r\n    }\r\n#else\r\n#define ssAddOutputDimsDependencyRule(S, outIdx, ruleInfo)\r\n#endif\r\n\r\n/**\r\n * @brief ssAddVariableSizeSignalsRuntimeChecker\r\n *\r\n * Register a method to check the current input dimensions\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    checker_type  Enum value corresponding to the checker type.\r\n */\r\n#if SS_SFCN && SS_SIM\r\n#define ssAddVariableSizeSignalsRuntimeChecker(S, checker_type)                                   \\\r\n    {                                                                                             \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ADD_VARDIMS_RUNTIME_CHECKER, (checker_type), \\\r\n                                        NULL) _ssSafelyCallGenericFcnEnd;                         \\\r\n    }\r\n#endif\r\n\r\n/**\r\n * @brief ssRegMdlSetInputPortDimensionsModeFcn\r\n *\r\n * Register the method to handle dimensions mode propagation for each input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    fcn           Function pointer corresponding to the function being registered.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssRegMdlSetInputPortDimensionsModeFcn(S, fcn)                                       \\\r\n    {                                                                                       \\\r\n        mdlSetInputPortDimensionsModeFcn _mdlDimsModeFcn = fcn;                             \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_REG_SET_INPUT_DIMS_MODE_MTH, 0,        \\\r\n                                        (void*)_mdlDimsModeFcn) _ssSafelyCallGenericFcnEnd; \\\r\n    }\r\n#else\r\n#define ssRegMdlSetInputPortDimensionsModeFcn(S, fcn)\r\n#endif\r\n\r\n/**\r\n * @brief ssSetDWorkRequireResetForSignalSize\r\n *\r\n * Set the block flag for resetting the index Dwork size upon subsystem reset.\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    index         Dwork index.\r\n * @param    n             Enum value corresponding to the signal size compute type.\r\n */\r\n#define ssSetDWorkRequireResetForSignalSize(S, index, n) \\\r\n    (S)->work.dWorkAux[index].flags.ensureResetForSizeVary = (unsigned int)(n)\r\n\r\n\r\n/**\r\n * @brief ssSetSignalSizesComputeType\r\n *\r\n * Set the type of ouput dependency on the input signal\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    type          Enum value corresponding to the signal size compute type.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssSetSignalSizesComputeType(S, type)                                                   \\\r\n    {                                                                                          \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_COMP_VARSIZE_COMPUTE_TYPE, (type), 0) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                        \\\r\n    }\r\n#else\r\n#define ssSetSignalSizesComputeType(S, type)\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssSetVectorMode\r\n *\r\n * Specify the vector mode that an S-function supports\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    n             Vector mode\r\n */\r\n#define ssSetVectorMode(S, n) (S)->sizes.flags.vectMode = (n)\r\n\r\n\r\n/**\r\n * @brief ssGetCurrentInputPortDimensions\r\n *\r\n * Get the current size of dimension dIdx of input port pIdx\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Input port index being polled.\r\n * @param    dIdx          Index of dimension being polled.\r\n * @return   An int_T value indicating the size of dimension dIdx.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetCurrentInputPortDimensions(S, pIdx, dIdx) \\\r\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(pIdx)].portVarDims[(dIdx)]\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetCurrentInputPortDimensions(S, pIdx, dIdx) \\\r\n    (S)->blkInfo.blkInfo2->portInfo2->inputs[(pIdx)].portVarDims[(dIdx)]\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssGetCurrentInputPortWidth\r\n *\r\n * Get the total width (total number of elements) of the signal at input port pIdx\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    portIdx          Input port index being polled.\r\n * @return   An int_T value indicating the current width of the signal at input port portIdx.\r\n */\r\n#define ssGetCurrentInputPortWidth(S, portIdx) _ssGetCurrentInputPortWidth(S, portIdx)\r\n\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortDimensions\r\n *\r\n * Get the dimensions of the signal accepted by an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port\r\n * @return   A pointer (int_T *) to an array of integers. The array contains elements with the\r\n * value DYNAMICALLY_SIZED (-1) when the size of a dimension is unknown.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetInputPortDimensions(S, port) (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetInputPortDimensions(S, port) ((S)->portInfo.inputs[(port)].dims)\r\n#endif\r\n\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortDimensionSize\r\n *\r\n * Get the size of one dimension of the signal entering an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port.\r\n * @param    dIdx          Index of the dimension.\r\n * @return   An int_T value indicating the size of dimension, dIdx, at the input port specified by\r\n * port. Returns 1 if the dIdx is greater than or equal to the number of input port dimensions.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetInputPortDimensionSize(S, port, dIdx)                           \\\r\n    ((dIdx) < ssGetInputPortNumDimensions((S), (port))                       \\\r\n         ? (S)->blkInfo.blkInfo2->blkInfoSLSize->inputs[(port)].dims[(dIdx)] \\\r\n         : 1)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetInputPortDimensionSize(S, port, dIdx)                                                 \\\r\n    ((dIdx) < ssGetInputPortNumDimensions((S), (port)) ? (S)->portInfo.inputs[(port)].dims[(dIdx)] \\\r\n                                                       : 1)\r\n#endif\r\n\r\n#endif\r\n\r\n/**\r\n * @brief ssGetInputPortDimensionsMode\r\n *\r\n * Get the dimensions mode of the input port indexed by pIdx\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Input port index being polled.\r\n * @return   A DimensionsMode_T value indicating the current dimensions mode.\r\n * Possible values are INHERIT_DIMS_MODE FIXED_DIMS_MODE and VARIABLE_DIMS_MODE.\r\n */\r\n#if SS_SIM\r\n#define ssGetInputPortDimensionsMode(S, pIdx) \\\r\n    CONV_BITS2DIMSMODE((S)->portInfo.inputs[(pIdx)].attributes.dimensionsMode)\r\n#else\r\n#define ssGetInputPortDimensionsMode(S, pIdx) ssGetInputPortDimensionsMode_cannot_be_used_in_RTW\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortNumDimensions\r\n *\r\n * Get the dimensions mode of the signals accepted by an input port.\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port.\r\n * @return   A positive integer indicating the number of dimensions of the input port specified by\r\n * the index port, or DYNAMICALLY_SIZED, if the number of dimensions is unknown.\r\n */\r\n#define ssGetInputPortNumDimensions(S, port)            \\\r\n    ((S)->portInfo.inputs[(port)].numDims) /*   (int_T) \\\r\n                                            */\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssGetCurrentOutputPortDimensions\r\n *\r\n * Get the current size of dimension dIdx of the signal at output port pIdx.\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Output port index being polled.\r\n * @param    dIdx          Index of dimension being polled.\r\n * @return   An int_T value indicating the size of dimension dIdx\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetCurrentOutputPortDimensions(S, pIdx, dIdx) \\\r\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(pIdx)].portVarDims[(dIdx)]\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetCurrentOutputPortDimensions(S, pIdx, dIdx) \\\r\n    (S)->blkInfo.blkInfo2->portInfo2->outputs[(pIdx)].portVarDims[(dIdx)]\r\n#endif\r\n\r\n/**\r\n * @brief ssGetCurrentOutputPortDimensionsAndRecordIndex\r\n *\r\n * Get the current size of dimension dIdx of the signal at output port pIdx and record this port\r\n * index.\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Output port index being polled.\r\n * @param    dIdx          Index of dimension being polled.\r\n * @return   An int_T value indicating the size of dimension dIdx\r\n */\r\n#define ssGetCurrentOutputPortDimensionsAndRecordIndex(S, pIdx, dIdx)                            \\\r\n    *((_ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_ADD_OUTPUT_VARDIMS_PORT_INDEX, (pIdx), NULL) \\\r\n           _ssSafelyCallGenericFcnEnd)                                                           \\\r\n          ? &(ssGetCurrentOutputPortDimensions(S, pIdx, dIdx))                                   \\\r\n          : &(ssGetCurrentOutputPortDimensions(S, pIdx, dIdx)))\r\n\r\n/**\r\n * @brief ssGetCurrentOutputPortWidth\r\n *\r\n * Get the total (total number of elements) of the signal at output port pIdx\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    portIdx          Output port index being polled.\r\n * @return   An int_T value indicating the current width of the signal at output port portIdx.\r\n */\r\n#define ssGetCurrentOutputPortWidth(S, portIdx) _ssGetCurrentOutputPortWidth(S, portIdx)\r\n\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetOutputPortDimensions\r\n *\r\n * Get the dimensions of the signal leaving an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port\r\n * @return   A pointer (int_T *) to an array of integers. The array contains elements with the value\r\n * DYNAMICALLY_SIZED (-1) when the size of a dimension is unknown.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetOutputPortDimensions(S, port) \\\r\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetOutputPortDimensions(S, port) ((S)->portInfo.outputs[(port)].dims)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetOutputPortDimensionSize\r\n *\r\n * Get the size of one dimension of the signal leaving an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port.\r\n * @param    dIdx          Index of the dimension.\r\n * @return   An int_T value indicating the size of dimension, dIdx, at the output port specified by\r\n * port. Returns 1 if the dIdx is greater than or equal to the number of output port dimensions.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetOutputPortDimensionSize(S, port, dIdx)                           \\\r\n    ((dIdx) < ssGetOutputPortNumDimensions((S), (port))                       \\\r\n         ? (S)->blkInfo.blkInfo2->blkInfoSLSize->outputs[(port)].dims[(dIdx)] \\\r\n         : 1)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetOutputPortDimensionSize(S, port, dIdx)     \\\r\n    ((dIdx) < ssGetOutputPortNumDimensions((S), (port)) \\\r\n         ? (S)->portInfo.outputs[(port)].dims[(dIdx)]   \\\r\n         : 1)\r\n#endif\r\n\r\n#endif\r\n/**\r\n * @brief ssGetOutputPortDimensionsMode\r\n *\r\n * Get the dimensions mode of the output port indexed by pIdx\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Output Port index being polled.\r\n * @return   A DimensionsMode_T value indicating the current dimensions mode. Possible values are\r\n * INHERIT_DIMS_MODE FIXED_DIMS_MODE and VARIABLE_DIMS_MODE.\r\n */\r\n#if SS_SIM\r\n#define ssGetOutputPortDimensionsMode(S, pIdx) \\\r\n    CONV_BITS2DIMSMODE((S)->portInfo.outputs[(pIdx)].attributes.dimensionsMode)\r\n#else\r\n#define ssGetOutputPortDimensionsMode(S, pIdx) ssGetOutputPortDimensionsMode_cannot_be_used_in_RTW\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetOutputPortNumDimensions\r\n *\r\n * Get the number of dimensions of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port\r\n * @return   A positive integer indicating the number of dimensions of the output port specified\r\n * by the index port, or DYNAMICALLY_SIZED, if the number of dimensions is unknown.\r\n */\r\n#define ssGetOutputPortNumDimensions(S, port) \\\r\n    ((S)->portInfo.outputs[(port)].numDims) /*   (int_T) */\r\n#endif\r\n\r\n/** @} */ /* end of SignalDims */\r\n\r\n/** @defgroup SignalAccess Signal Access\r\n **\r\n *  @{\r\n */\r\n\r\n/** Signal Access **/\r\n\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n#if !SS_DEBUG_FOR_SIM\r\n/**\r\n * @brief ssGetInputPortBufferDstPort\r\n *\r\n * Determine the output port that is sharing this input port's buffer\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port on S\r\n * @return   The int_T index of the output port that reuses the memory buffer of the input port\r\n * indicated by the index inputPortIdx. If none of the S-function's output ports reuse this input\r\n * port buffer, returns INVALID_PORT_IDX (-1).\r\n */\r\n#define ssGetInputPortBufferDstPort(S, port) \\\r\n    ((S)->portInfo.inputs[(port)].bufferDstPort) /* (int_T) */\r\n#endif /* !SS_DEBUG_FOR_SIM */\r\n#endif /* !SS_SFCN_LEVEL_1 */\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortConnected\r\n *\r\n * Determine whether a port is connected to a nonvirtual block\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Port whose connected status is needed.\r\n * @return   Either an int_T (1 or 0) or boolean_T (true or false) value indicating if the\r\n * input port specified by the index port is connected to a nonvirtual block.\r\n */\r\n#define ssGetInputPortConnected(S, port) (S)->portInfo.inputs[(port)].connected /* (int_T) */\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortOptimOpts\r\n *\r\n * Get the reusability setting of the memory allocated to the input port of an S-function\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port of S.\r\n * @return   One of the followings: SS_NOT_REUSABLE_AND_GLOBAL,SS_REUSABLE_AND_LOCAL,\r\n * SS_REUSABLE_AND_GLOBAL, SS_NOT_REUSABLE_AND_LOCAL\r\n */\r\n#define ssGetInputPortOptimOpts(S, port) ((S)->portInfo.inputs[(port)].attributes.optimOpts)\r\n\r\n/**\r\n * @brief ssSetInputPortOptimOpts\r\n *\r\n * Specify reusability of the memory allocated to the input port of an S-function\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port of S.\r\n * @param    val           One of the followings: SS_NOT_REUSABLE_AND_GLOBAL,SS_REUSABLE_AND_LOCAL,\r\n * SS_REUSABLE_AND_GLOBAL, SS_NOT_REUSABLE_AND_LOCAL\r\n */\r\n#define ssSetInputPortOptimOpts(S, port, val) \\\r\n    ((S)->portInfo.inputs[(port)].attributes.optimOpts = (val))\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetInputPortOverWritable\r\n *\r\n * Determine whether an input port can be overwritten\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port whose overwritability is required.\r\n * @return   An int_T (1 or 0) or boolean_T (true or false) value indicating if the input port\r\n * specified by the index port can be overwritten.\r\n */\r\n#define ssGetInputPortOverWritable(S, port) \\\r\n    ((S)->portInfo.inputs[(port)].attributes.overWritable == 1U)\r\n\r\n/**\r\n * @brief ssSetInputPortOverWritable\r\n *\r\n * Specify whether one of an S-function's input ports can be overwritten by one of its output ports\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an input port whose overwritability is being set.\r\n * @param    val           Value specifying whether port is overwritable.\r\n */\r\n#define ssSetInputPortOverWritable(S, port, val) \\\r\n    ((S)->portInfo.inputs[(port)].attributes.overWritable = (val) ? 1U : 0U)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n#if !SS_DEBUG_FOR_SIM\r\n/**\r\n * @brief ssGetInputPortSignal\r\n *\r\n * Get the address of a contiguous signal entering an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    ip            Index of the port whose address is required.\r\n * @return   A pointer (void *) to the input port specified by the index ip.\r\n */\r\n#define ssGetInputPortSignal(S, ip) ((S)->portInfo.inputs[(ip)].signal.vect) /* (const void *) */\r\n\r\n/**\r\n * @brief ssGetInputPortRealSignal\r\n *\r\n * Get the address of a real, contiguous signal entering an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    ip            Index of the port whose address is required.\r\n * @return   A pointer (real_T *) to a real signal on the input port specified by the index ip.\r\n */\r\n#define ssGetInputPortRealSignal(S, ip) ((const real_T*)ssGetInputPortSignal(S, ip))\r\n\r\n/**\r\n * @brief ssGetInputPortSignalPtrs\r\n *\r\n * Get pointers to an input port's signal elements\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    ip            Index of the input port\r\n * @return   Pointer to an array of signal element pointers for the specified input port ip.\r\n */\r\n#define ssGetInputPortSignalPtrs(S, ip) \\\r\n    ((S)->portInfo.inputs[(ip)].signal.ptrs) /* (InputPtrsType) */\r\n\r\n/**\r\n * @brief ssGetInputPortRealSignalPtrs\r\n *\r\n * Get pointers to signals of type double connected to an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    ip            Index of the input port\r\n * @return   Pointers to the elements of a signal of type double connected to the input port\r\n * specified by the index ip.\r\n */\r\n#define ssGetInputPortRealSignalPtrs(S, ip) ((InputRealPtrsType)ssGetInputPortSignalPtrs(S, ip))\r\n#endif /* __SS_DEBUG_FOR_SIM__ */\r\n#endif /*__!SS_SFCN_LEVEL_1_*/\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetOutputPortConnected\r\n *\r\n * Determine whether an output port is connected to a nonvirtual block\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Port whose connection status is needed.\r\n * @return   An int_T (1 or 0) or boolean_T (true or false) value indicating if this output port\r\n * signal is connected to a nonvirtual block.\r\n */\r\n#define ssGetOutputPortConnected(S, port) (S)->portInfo.outputs[(port)].connected /* (int_T) */\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetOutputPortBeingMerged\r\n *\r\n * Determine whether an output port of this block is connected to a Merge block\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the output port\r\n * @return   An int_T (1 or 0) or boolean_T (true or false) value indicating if this output port\r\n * signal is being merged with other signals.\r\n */\r\n#define ssGetOutputPortBeingMerged(S, port) \\\r\n    ((S)->portInfo.outputs[(port)].attributes.cToMergeBlk == 1U)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetOutputPortOptimOpts\r\n *\r\n * Get the reusability setting of the memory allocated to the output port of an S-function\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the output port\r\n * @return   One of the following values: SS_NOT_REUSABLE_AND_GLOBAL,SS_REUSABLE_AND_LOCAL,\r\n * SS_REUSABLE_AND_GLOBAL, SS_NOT_REUSABLE_AND_LOCAL\r\n */\r\n#define ssGetOutputPortOptimOpts(S, port) ((S)->portInfo.outputs[(port)].attributes.optimOpts)\r\n\r\n/**\r\n * @brief ssSetOutputPortOptimOpts\r\n *\r\n * Specify reusability of the memory allocated to the output port of an S-function\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the output port\r\n * @param    val           Permissible values: SS_NOT_REUSABLE_AND_GLOBAL,SS_REUSABLE_AND_LOCAL,\r\n * SS_REUSABLE_AND_GLOBAL, SS_NOT_REUSABLE_AND_LOCAL\r\n */\r\n#define ssSetOutputPortOptimOpts(S, port, val) \\\r\n    ((S)->portInfo.outputs[(port)].attributes.optimOpts = (val))\r\n\r\n#endif\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetOutputPortRealSignal\r\n *\r\n * Get a pointer to an output signal of type double (real_T)\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the output port\r\n * @return   A contiguous real_T vector of length equal to the width of the output port.\r\n */\r\n#define ssGetOutputPortRealSignal(S, port) \\\r\n    ((real_T*)(S)->portInfo.outputs[(port)].signalVect) /* (real_T*)       */\r\n#endif\r\n\r\n/**\r\n * @brief ssSetOutputPortOverwritesInputPort\r\n *\r\n * Specify whether an output port can share its memory buffer with an input port.\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    pIdx          Index of the output port.\r\n * @return   val           Index of the input port.\r\n */\r\n#if SS_SFCN && SS_SIM\r\n#define ssSetOutputPortOverwritesInputPort(S, pIdx, val)                                     \\\r\n    {                                                                                        \\\r\n        int inpIdx = val;                                                                    \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_OUTPUT_OVERWRITE_INPUT_IDX, (pIdx), \\\r\n                                        (&inpIdx)) _ssSafelyCallGenericFcnEnd;               \\\r\n    }\r\n#endif\r\n\r\n/** @} */ /* end of SignalAccess */\r\n\r\n/** @} */ /* end of InputOutputPorts */\r\n\r\n\r\n/** @defgroup SampleTime Sample Time\r\n *  @{\r\n */\r\n/*======================================*\r\n * Sample Time *\r\n *======================================*/\r\n\r\n/**\r\n * @brief ssGetSampleTime\r\n *\r\n * Get one of an S-function's sample times\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    sti           Index of the sample time to be returned.\r\n * @return   A time_T value indicating the sample time associated with the index sti.\r\n */\r\n#define ssGetSampleTime(S, sti) (S)->stInfo.sampleTimes[sti] /*   (time_T)      */\r\n\r\n/**\r\n * @brief ssSetSampleTime\r\n *\r\n * Set the period of a sample time\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    sti           Index of the sample time to be set.\r\n * @param    t             Period of the sample time specified by sti.\r\n * @return   The time_T sample time value specified by period.\r\n */\r\n#define ssSetSampleTime(S, sti, t) (S)->stInfo.sampleTimes[sti] = (t)\r\n\r\n\r\n/**\r\n * @brief ssGetInputPortSampleTime\r\n *\r\n * Get the sample time of an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the input port whose sample time is required.\r\n * @return   The real_T value of the sample time of the input port specified by the index port.\r\n */\r\n#define ssGetInputPortSampleTime(S, port) \\\r\n    ((S)->portInfo.inputs[(port)].sampleTime) /* (real_T)      */\r\n\r\n/**\r\n * @brief ssSetInputPortSampleTime\r\n *\r\n * Specify the sample time of an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the input port whose sample time is being set.\r\n * @param    val           Sample period\r\n * @return   The real_T value of the sample time passed into the macro.\r\n */\r\n#define ssSetInputPortSampleTime(S, port, val) \\\r\n    (S)->portInfo.inputs[(port)].sampleTime = (val) /* (real_T)      */\r\n\r\n\r\n\r\n/**\r\n * @brief ssGetNumSampleTimes\r\n *\r\n * Get the number of sample times that a block has\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @return   An int_T value indicating the total number of port-based and block-based sample times.\r\n * Returns -1 if the block has unspecified port-based sample times.\r\n */\r\n#define ssGetNumSampleTimes(S) (S)->sizes.numSampleTimes /*   (int_T)       */\r\n\r\n/**\r\n * @brief ssSetNumSampleTimes\r\n *\r\n * Specify the number of sample times that a block has\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    nSampleTimes  Number of sample times that S has.\r\n * @return   The number of sample times specified by nSampleTimes, or -1 if PORT_BASED_SAMPLE_TIMES.\r\n */\r\n#define ssSetNumSampleTimes(S, nSampleTimes) (S)->sizes.numSampleTimes = (nSampleTimes)\r\n\r\n\r\n/**\r\n * @brief ssGetOffsetTime\r\n *\r\n * Get one of an S-function's sample time offsets.\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    sti           Index of the sample time whose offset is to be set.\r\n * @return   A time_T value indicating the sample time offset.\r\n */\r\n#define ssGetOffsetTime(S, sti) (S)->stInfo.offsetTimes[sti] /*   (time_T)      */\r\n\r\n/**\r\n * @brief ssSetOffsetTime\r\n *\r\n * Set the offset time of a block\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    sti           Index of the sample time whose offset is to be set.\r\n * @param    offset        Offset of the sample time specified by sti.\r\n * @return   The time_T offset value specified by offset.\r\n */\r\n#define ssSetOffsetTime(S, sti, t) (S)->stInfo.offsetTimes[sti] = (t)\r\n\r\n/**\r\n * @brief ssGetTNext\r\n *\r\n * Get the time of the next sample hit\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @return   A value of type time_T.\r\n */\r\n#define ssGetTNext(S) (S)->stInfo.tNext /*   (time_T)      */\r\n\r\n/**\r\n * @brief ssSetTNext\r\n *\r\n * Set the time of the next sample hit\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    tnext         Time of the next sample hit.\r\n */\r\n#define ssSetTNext(S, tnext) (S)->stInfo.tNext = (tnext)\r\n\r\n/**\r\n * @brief ssGetInputPortSampleTimeIndex\r\n *\r\n * Get the sample time index of an input port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the input port whose sample time index is to be returned.\r\n */\r\n#define ssGetInputPortSampleTimeIndex(S, port) \\\r\n    (S)->portInfo.inputs[(port)].sampleTimeIndex /* (int_T)       */\r\n\r\n/**\r\n * @brief ssGetOutputPortSampleTime\r\n *\r\n * Get the sample time of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the output port\r\n * @return   A real_T value indicating the sample time of the output port specified by the index\r\n * port.\r\n */\r\n#define ssGetOutputPortSampleTime(S, port) \\\r\n    ((S)->portInfo.outputs[(port)].sampleTime) /* (real_T)      */\r\n\r\n/**\r\n * @brief ssGetOutputPortSampleTimeIndex\r\n *\r\n * Get the sample time index of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of the output port\r\n * @return   An int_T value indicating the sample time index for the output port specified by the\r\n * index outputPortIdx. Returns CONSTANT_TID (-2) for constant (inf) sample times.\r\n */\r\n#define ssGetOutputPortSampleTimeIndex(S, port) \\\r\n    (S)->portInfo.outputs[(port)].sampleTimeIndex /* (int_T)       */\r\n\r\n\r\n\r\n/**\r\n * @brief ssGetPortBasedSampleTimeBlockIsTriggered\r\n *\r\n * Determine whether a block that uses port-based sample times resides in a triggered subsystem\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @return   The Boolean value true if S uses port-based sample times and resides in a triggered\r\n * subsystem. Otherwise, returns false.\r\n */\r\n#define ssGetPortBasedSampleTimeBlockIsTriggered(S) \\\r\n    ((S)->stInfo.sampleTimes[0] == INHERITED_SAMPLE_TIME)\r\n\r\n/**\r\n * @brief ssSetDeepCopyCompliant\r\n *\r\n * Set compliant to data types with deep copy\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    dtype         Logical value indicating whether to allow a datatype with deepcopy\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n\r\n#define ssSetDeepCopyCompliant(S, flag)                                            \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_DEEPCOPY_COMPLIANT, flag, NULL) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n#else\r\n\r\n#define ssSetDeepCopyCompliant(S, flag)\r\n\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssSetParameterTuningCompliance\r\n *\r\n * Specify sample time behavior and tunability for S-function blocks with port-based sample times\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    flag          Logical value indicating whether to allow a sample time of Inf for\r\n * ports in the S-function.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n\r\n#define ssSetParameterTuningCompliance(S, flag)                                       \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_PRM_TUNING_COMPLIANCE, flag, NULL) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n#else\r\n\r\n#define ssSetParameterTuningCompliance(S, flag)\r\n\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssGetParameterTuningCompliance\r\n *\r\n * Get the sample time behavior and tunability for S-function blocks with port-based sample times\r\n * @param    S             SimStruct representing an S-Function block.\r\n */\r\n#if SS_SFCN_FOR_SIM\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\nextern boolean_T ssGetParameterTuningCompliance(SimStruct* S);\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssIsContinuousTask\r\n *\r\n * Determine whether a task is continuous\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    tid           Task ID\r\n * @return   The Boolean value true when the simulation is executing the continuous task. Otherwise,\r\n * returns false.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#if defined(RSIM_WITH_SOLVER_MULTITASKING) && RSIM_WITH_SOLVER_MULTITASKING\r\n#if SS_TID01EQ_EQUAL_ONE\r\n#define ssIsContinuousTask(S, tid) ((tid) <= 1)\r\n#else\r\n#define ssIsContinuousTask(S, tid) ((tid) == 0)\r\n#endif\r\n#else\r\n/*\r\n * During simulation, tid passed to S-functions is always 0 even in\r\n * multitasking mode\r\n */\r\n#define ssIsContinuousTask(S, tid) (((tid) == 0) && (S)->mdlInfo->sampleHits[0])\r\n#endif\r\n#elif SS_TID01EQ_EQUAL_ONE\r\n#define ssIsContinuousTask(S, tid) ((tid) <= 1)\r\n#else\r\n#define ssIsContinuousTask(S, tid) ((tid) == 0)\r\n#endif\r\n\r\n/**\r\n * @brief ssIsSampleHit\r\n *\r\n * Determine whether the sample time is hit\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    sti           Index of the sample time\r\n * @param    tid           Task ID\r\n * @return   The Boolean value true when the simulation is executing in the task represented\r\n * by task ID tid. Otherwise, returns false.\r\n */\r\n#if SS_MULTITASKING || (defined(RSIM_WITH_SOLVER_MULTITASKING) && RSIM_WITH_SOLVER_MULTITASKING)\r\n\r\n#define ssIsSampleHit(S, sti, tid) \\\r\n    (!ssIsTIDInStInfo(S, sti) || (ssGetSampleTimeTaskID(S, sti) == (tid)))\r\n\r\n#else\r\n\r\n#define ssIsSampleHit(S, sti, tid) \\\r\n    (((tid) != CONSTANT_TID) &&    \\\r\n     (!ssIsTIDInStInfo(S, sti) ||  \\\r\n      (ssIsMajorTimeStep(S) && (ssGetSampleHitPtr(S))[ssGetSampleTimeTaskID(S, sti)])))\r\n\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssIsSpecialSampleHit\r\n *\r\n * Determine whether the sample time is hit\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    my_sti        Index of the sample time\r\n * @param    promoted_sti  Index of the sample time\r\n * @param    tid           Task ID\r\n * @return   The Boolean value true if a sample hit has occurred at sti1 and a sample hit has\r\n * also occurred at sti2 in the same time step. Otherwise, returns false.\r\n */\r\n#if SS_MULTITASKING || SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n/*\r\n * The ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid) macro will be\r\n * \"true\" if the block is executing in a major time step in context of a\r\n * promoted sample time (promoted_sti) and we have a sample hit in the\r\n * original task (my_sti) which translates to:\r\n *    1) tid == tid_for(promoted_sti). It is required that this macro be\r\n *       invoked with in a ssIsSampleHit(S,promoted_sti,tid) to guarantee this\r\n *       case.\r\n *    2) Must be major time step.\r\n *    3) my_sti (the block's sti) has a sample hit at the current point in\r\n *       time.\r\n * Valid usage in an S-function would be:\r\n *\tif (ssIsSampleHit(S, promoted_sti)) {\r\n *        if (ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid)) {\r\n *        }\r\n *      }\r\n * providing promoted_sti is not the continuous task. If promoted_sti is\r\n * the continuous task, then the following must be used:\r\n *\tif (ssIsContinuousTask(S, promoted_sti)) {\r\n *        if (ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid)) {\r\n *        }\r\n *      }\r\n *\r\n * Note, failure to wrap ssIsSpecialSampleHit() within ssIsSampleHit() or\r\n * ssIsContinuousTask will result in unexpected behavior.\r\n */\r\n#define ssIsSampleHitInTask(S, my_sti, tid) \\\r\n    (ssGetPerTaskSampleHitsPtr(             \\\r\n        S))[ssGetSampleTimeTaskID(S, my_sti) + ((tid) * (ssGetNumRootSampleTimes(S)))]\r\n\r\n#define ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid) \\\r\n    (ssIsMajorTimeStep(S) && ssIsSampleHitInTask(S, my_sti, ssGetSampleTimeTaskID(S, promoted_sti)))\r\n#else\r\n#define ssIsSpecialSampleHit(S, my_sti, promoted_sti, tid) ssIsSampleHit(S, my_sti, tid)\r\n#endif\r\n\r\n/**\r\n * @brief ssSampleAndOffsetAreTriggered\r\n *\r\n * Determine whether a sample time and offset value pair indicate a triggered sample time\r\n * @param    st            The sample time.\r\n * @param    ot            The offset time.\r\n * @return   The Boolean value true if both st and ot are equal to INHERITED_SAMPLE_TIME. Otherwise,\r\n * returns false.\r\n */\r\n#define ssSampleAndOffsetAreTriggered(st, ot) \\\r\n    ((st == INHERITED_SAMPLE_TIME) && (ot == INHERITED_SAMPLE_TIME))\r\n\r\n/**\r\n * @brief ssSampleAndOffsetAreTriggeredOrAsync\r\n *\r\n * Determine whether a sample time and offset value pair indicate a triggered or asynchronous sample\r\n * time\r\n * @param    st            The sample time.\r\n * @param    ot            The offset time.\r\n * @return   The Boolean value true if st is equal to INHERITED_SAMPLE_TIME (-1) and ot is either\r\n * INHERITED_SAMPLE_TIME (-1) or any other negative integer.\r\n */\r\n#define ssSampleAndOffsetAreTriggeredOrAsync(st, ot) \\\r\n    ((st == INHERITED_SAMPLE_TIME) && (ot <= INHERITED_SAMPLE_TIME))\r\n\r\n/**\r\n * @brief ssSetControllableSampleTime\r\n *\r\n * Register controllable sample time in a block\r\n * @param    S          SimStruct representing an S-Function block\r\n * @param    sti        Index of the contollable sample time in the block.\r\n * @param    base       Sample time resolution of the block. This is the smallest time step that the\r\n * block can take Events of the block can be set to occur at integral multiples of resolution.\r\n *\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssSetControllableSampleTime(S, sti, base)                                                \\\r\n    {                                                                                            \\\r\n        real_T tmp = base;                                                                       \\\r\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_CONTROLLABLE_SAMPLE_TIME, (int)sti, &tmp) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                          \\\r\n    }\r\n#else\r\n#define ssSetControllableSampleTime(S, sti, base)\r\n#endif\r\n\r\n\r\n/** @} */ /* end of SampleTime */\r\n\r\n/** @defgroup DataType Data Type\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Data Type *\r\n *======================================*/\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssRegisterDataType\r\n *\r\n * Register a custom data type\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    name          Name of the custom data type.\r\n * @return   The DTypeId associated with the registered data type.\r\n *  Otherwise, reports an error and returns INVALID_DTYPE_ID.\r\n */\r\n#if SS_SIM\r\n#define ssRegisterDataType(S, name)                                       \\\r\n    (((S)->regDataType.registerFcn != NULL)                               \\\r\n         ? (*(S)->regDataType.registerFcn)((S)->regDataType.arg1, (name)) \\\r\n         : (INVALID_DTYPE_ID))\r\n#else\r\n#define ssRegisterDataType(S, name) ssRegisterDataType_cannot_be_used_in_RTW\r\n#endif\r\n\r\n/**\r\n * @brief ssSetDataTypeSize\r\n *\r\n * Set the size of a custom data type\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    id            ID of the data type.\r\n * @param    size          Size of the custom data type in bytes\r\n * @return   1 (true) if successful. Otherwise, returns 0 (false).\r\n */\r\n#if SS_SIM\r\n#define ssSetDataTypeSize(S, id, size)                                         \\\r\n    (((S)->regDataType.setSizeFcn != NULL)                                     \\\r\n         ? (*(S)->regDataType.setSizeFcn)((S)->regDataType.arg1, (id), (size)) \\\r\n         : (0))\r\n#else\r\n#define ssSetDataTypeSize(S, id, size) ssSetDataTypeSize_cannot_be_used_in_RTW\r\n#endif\r\n\r\n/**\r\n * @brief ssGetDataTypeSize\r\n *\r\n * Get the size of a custom data type\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    id            ID of the data type.\r\n * @return   An int_T value indicating the size of the data type specified by id, if id is valid and\r\n * the data type's size has been set. Otherwise, returns INVALID_DTYPE_SIZE and reports an error.\r\n */\r\n#if SS_SIM\r\n#define ssGetDataTypeSize(S, id)                                       \\\r\n    (((S)->regDataType.getSizeFcn != NULL)                             \\\r\n         ? (*(S)->regDataType.getSizeFcn)((S)->regDataType.arg1, (id)) \\\r\n         : (INVALID_DTYPE_SIZE))\r\n#else\r\n#define ssGetDataTypeSize(S, id) ssGetDataTypeSize_cannot_be_used_in_RTW\r\n#endif\r\n\r\n/**\r\n * @brief ssGetNumDataTypes\r\n *\r\n * Get number of data types registered for this simulation, including build-in types\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @return   An int_T value indicating the number of registered data types.\r\n */\r\n#if SS_SIM\r\n#define ssGetNumDataTypes(S) (dtaGetNumDataTypes(ssGetDataTypeAccess(S)))\r\n#else\r\n#define ssGetNumDataTypes(S) ssGetNumDataTypes_cannot_be_used_in_RTW\r\n#endif\r\n\r\n/**\r\n * @brief ssSetDataTypeZero\r\n *\r\n * Set the zero representation of a data type\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    id            ID of the data type.\r\n * @param    zero          Zero representation of the data type specified by id.\r\n * @return   1 (true) if successful. Otherwise, returns 0 (false) and reports an error.\r\n */\r\n#if SS_SIM\r\n#define ssSetDataTypeZero(S, id, zero)                                         \\\r\n    (((S)->regDataType.setZeroFcn != NULL)                                     \\\r\n         ? (*(S)->regDataType.setZeroFcn)((S)->regDataType.arg1, (id), (zero)) \\\r\n         : (0))\r\n#else\r\n#define ssSetDataTypeZero(S, id, zero) ssSetDataTypeZero_cannot_be_used_in_RTW\r\n#endif\r\n\r\n/**\r\n * @brief ssGetDataTypeZero\r\n *\r\n * Get the zero representation of a data type\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    id            ID of the data type.\r\n * @return   A pointer (void *) to the zero representation of the data type specified by id,\r\n * if id is valid and the data type's size has been set. Otherwise, returns NULL and reports an\r\n * error.\r\n */\r\n#if SS_SIM\r\n#define ssGetDataTypeZero(S, id)                                       \\\r\n    (((S)->regDataType.getZeroFcn != NULL)                             \\\r\n         ? (*(S)->regDataType.getZeroFcn)((S)->regDataType.arg1, (id)) \\\r\n         : (NULL))\r\n#else\r\n#define ssGetDataTypeZero(S, id) ssGetDataTypeZero_cannot_be_used_in_RTW\r\n#endif\r\n\r\n/**\r\n * @brief ssGetDataTypeId\r\n *\r\n * Get the ID of a data type\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    name          Name of a data type\r\n * @return   The ID of the custom data type specified by name if name is a registered type name.\r\n * Otherwise, returns INVALID_DTYPE_ID and reports an error.\r\n */\r\n#if SS_SIM\r\n#define ssGetDataTypeId(S, name)                                       \\\r\n    (((S)->regDataType.getIdFcn != NULL)                               \\\r\n         ? (*(S)->regDataType.getIdFcn)((S)->regDataType.arg1, (name)) \\\r\n         : (INVALID_DTYPE_ID))\r\n#else\r\n#define ssGetDataTypeId(S, name) ssGetDataTypeId_cannot_be_used_in_RTW\r\n#endif\r\n\r\n/**\r\n * @brief ssGetDataTypeName\r\n *\r\n * Get the name of a data type\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    id            ID of a data type.\r\n * @return   The name of the data type specified by id, if id is valid.\r\n * Otherwise, returns NULL and reports an error.\r\n */\r\n#if SS_SIM\r\n#define ssGetDataTypeName(S, id)                                       \\\r\n    (((S)->regDataType.getNameFcn != NULL)                             \\\r\n         ? (*(S)->regDataType.getNameFcn)((S)->regDataType.arg1, (id)) \\\r\n         : (NULL))\r\n#else\r\n#define ssGetDataTypeName(S, id) ssGetDataTypeName_cannot_be_used_in_RTW\r\n#endif\r\n\r\n/**\r\n * @brief ssGetDataTypeIdAliasedThruTo\r\n *\r\n * Get the base data type associated with a data type alias\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    id            ID of the data type alias\r\n * @return   The base data type ID associated with the data type alias specified by id.\r\n * Otherwise, returns NULL and reports an error.\r\n */\r\n#if SS_SIM\r\n#define ssGetDataTypeIdAliasedThruTo(S, id) \\\r\n    (dtaGetDataTypeIdAliasedThruTo(ssGetDataTypeAccess(S), (S)->path, (id)))\r\n#else\r\n#define ssGetDataTypeIdAliasedThruTo(S, id) ssGetDataTypeIdAliasedThruTo_cannot_be_used_in_RTW\r\n#endif\r\n\r\n#endif /* !SS_SFCN_LEVEL_1 */\r\n\r\n\r\n/**\r\n * @brief ssGetOutputPortDataType\r\n *\r\n * Get the data type of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port\r\n * @return   The data type ID of the output port specified by the index port.\r\n * Returns DYNAMICALLY_TYPED if the output port inherits its data type.\r\n */\r\n#define ssGetOutputPortDataType(S, port) \\\r\n    (S)->portInfo.outputs[(port)].dataTypeId /* (DTypeId)     */\r\n\r\n/**\r\n * @brief ssSetOutputPortDataType\r\n *\r\n * Set the data type of an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port\r\n * @param    dTypeId       ID of the data type accepted by port.\r\n * @return   The data type ID specified by id. Returns -1 if id is DYNAMICALLY_TYPED.\r\n */\r\n#define ssSetOutputPortDataType(S, port, dTypeId) \\\r\n    ((S)->portInfo.outputs[(port)].dataTypeId = (dTypeId))\r\n\r\n/**\r\n * @brief ssGetOutputPortSignal\r\n *\r\n * Get the vector of signal elements emitted by an output port\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    port          Index of an output port\r\n * @return   A pointer (void *) to the vector of signal elements output at the port specified by the\r\n * index port.\r\n */\r\n#define ssGetOutputPortSignal(S, port) \\\r\n    (S)->portInfo.outputs[(port)].signalVect /* (void *)        */\r\n\r\n/**\r\n * @brief ssGetSFcnParamDataType\r\n *\r\n * Get the data type of a parameter for an S-Function block\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    index         Index of the target parameter.\r\n * @param    result        ID of the parameter data type.\r\n */\r\n#define ssGetSFcnParamDataType(S, index, result)                                          \\\r\n    {                                                                                     \\\r\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_GET_PARAM_DATATYPE, (index), (result)) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                   \\\r\n    }\r\n\r\n/** @} */ /* end of DataType */\r\n\r\n/** @defgroup BlockDialogParam  Block Dialog Parameters\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Block Dialog Parameters *\r\n *======================================*/\r\n\r\n/**\r\n * @brief ssGetDTypeIdFromMxArray\r\n *\r\n * Get the data type of an S-function parameter\r\n * @param    m         MATLAB array representing the parameter\r\n * @return   The data type ID of an S-function parameter represented by a MATLAB array.\r\n * Returns INVALID_DTYPE_ID if the MATLAB data type does not map to any built-in Simulink data type\r\n * ID.\r\n */\r\n#if SS_SFCN_FOR_SIM\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\nextern DTypeId ssGetDTypeIdFromMxArray(const mxArray* m);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssGetNumSFcnParams\r\n *\r\n * Get the number of parameters that an S-Function block expects\r\n * @param    S        SimStruct representing an S-Function block.\r\n * @return   An int_T value indicating the number of expected S-function parameters\r\n */\r\n#define ssGetNumSFcnParams(S) (S)->sizes.numSFcnParams /*   (int_T)       */\r\n\r\n/**\r\n * @brief ssSetNumSFcnParams\r\n *\r\n * Specify the number of parameters that an S-Function block has\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    nSFcnParams   Number of parameters that S has.\r\n * @return   The number of parameters specified in nSFcnParams.\r\n */\r\n#define ssSetNumSFcnParams(S, nSFcnParams) (S)->sizes.numSFcnParams = (nSFcnParams)\r\n\r\n/**\r\n * @brief ssGetSFcnParam\r\n *\r\n * Get a parameter of an S-Function block\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    index         Index of the parameter to be returned\r\n * @return   A pointer (const mxArray *) to the value of the S-function parameter specified by\r\n * index.\r\n */\r\n#define ssGetSFcnParam(S, index)                                     \\\r\n    ((const mxArray*)_ssGetSFcnParam(S, index)) /* (const mxArray *) \\\r\n                                                 */\r\n\r\n\r\n/**\r\n * @brief ssGetSFcnParamsCount\r\n *\r\n * Get the number of block dialog parameters that an S-Function block has\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @return   An int_T value\r\n */\r\n#define ssGetSFcnParamsCount(S) (S)->sfcnParams.dlgNum /*   (int_T)       */\r\n\r\n\r\n\r\n/**\r\n * @brief ssSetSFcnParamTunable\r\n *\r\n * Make a block parameter tunable\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    index         Index of the parameter\r\n * @param    val           Valid values are SS_PRM_TUNABLE (true / tunable),\r\n * SS_PRM_NOT_TUNABLE (false / not tunable), or SS_PRM_SIM_ONLY_TUNABLE (tunable only during\r\n * simulation).\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#define ssSetSFcnParamTunable(S, index, val)                                                      \\\r\n    (S)->sfcnParams.dlgAttribs[index] =                                                           \\\r\n        (((ssParamTunability)val) == SS_PRM_TUNABLE)                                              \\\r\n            ? (((S)->sfcnParams.dlgAttribs[index] & SFCNPARAM_CLEAR_TUNABLE) | SFCNPARAM_TUNABLE) \\\r\n            : ((((ssParamTunability)val) == SS_PRM_SIM_ONLY_TUNABLE)                              \\\r\n                   ? (((S)->sfcnParams.dlgAttribs[index] & SFCNPARAM_CLEAR_TUNABLE) |             \\\r\n                      SFCNPARAM_SIMONLY_TUNABLE)                                                  \\\r\n                   : (((S)->sfcnParams.dlgAttribs[index] & SFCNPARAM_CLEAR_TUNABLE) |             \\\r\n                      SFCNPARAM_NOT_TUNABLE))\r\n#else /* RT or NRT */\r\n#define ssSetSFcnParamTunable(S, index, boolval) /* do nothing */\r\n#endif\r\n\r\n/** @} */ /* end of BlockDialogParam */\r\n\r\n/** @defgroup FcnCallSubsystem  Function-Call Subsystems\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Function-Call Subsystems *\r\n *======================================*/\r\n\r\n#if SS_RT\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\nextern int_T rt_CallSys(SimStruct* S, int_T element, int_T tid);\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n#define ssCallSystemWithTid(S, element, tid) \\\r\n    (((S)->callSys.fcns[(element)] != NULL) ? rt_CallSys((S), (element), (tid)) : 1)\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\nextern int_T rt_EnableSys(SimStruct* S, int_T element, int_T tid);\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n#define ssEnableSystemWithTid(S, element, tid)                                 \\\r\n    (((S)->callSys.fcns[ssGetOutputPortWidth((S), 0) + (element)] != NULL ||   \\\r\n      (S)->callSys.fcns[2 * ssGetOutputPortWidth((S), 0) + (element)] != NULL) \\\r\n         ? rt_EnableSys((S), (element), (tid))                                 \\\r\n         : 1)\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\nextern int_T rt_DisableSys(SimStruct* S, int_T element, int_T tid);\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#define ssDisableSystemWithTid(S, element, tid)                                \\\r\n    (((S)->callSys.fcns[3 * ssGetOutputPortWidth((S), 0) + (element)] != NULL) \\\r\n         ? rt_DisableSys((S), (element), (tid))                                \\\r\n         : 1)\r\n#else /* #if SS_RT */\r\n/**\r\n * @brief ssCallSystemWithTid\r\n *\r\n * Call the update and outputs methods of a function-call subsystem\r\n * @param    S         SimStruct representing an S-Function block.\r\n * @param    element   Index of the output port element corresponding to the function-call\r\n * subsystem.\r\n * @param    tid       Task ID.\r\n */\r\n#define ssCallSystemWithTid(S, element, tid)                                            \\\r\n    (((S)->callSys.fcns[(element)] != NULL)                                             \\\r\n         ? ((*(S)->callSys.fcns[(element)])((S)->callSys.args1[(element)],              \\\r\n                                            (S)->callSys.args2[(element)], (tid))       \\\r\n                ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\r\n                : (0))                                                                  \\\r\n         : (1))\r\n\r\n#if defined(RSIM_WITH_SL_SOLVER)\r\n#define ssEnableSystemWithTid(S, element, tid)                                           \\\r\n    ((((S)->callSys.fcns[ssGetOutputPortWidth((S), 0) + (element)] != NULL)              \\\r\n          ? ((*(S)->callSys.fcns[ssGetOutputPortWidth((S), 0) + (element)])(             \\\r\n                 (S)->callSys.args1[(element)], (S)->callSys.args2[(element)], (tid))    \\\r\n                 ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\r\n                 : (0))                                                                  \\\r\n          : (1)) &                                                                       \\\r\n     (((S)->callSys.fcns[2 * ssGetOutputPortWidth((S), 0) + (element)] != NULL)          \\\r\n          ? ((*(S)->callSys.fcns[2 * ssGetOutputPortWidth((S), 0) + (element)])(         \\\r\n                 (S)->callSys.args1[(element)], (S)->callSys.args2[(element)], (tid))    \\\r\n                 ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\r\n                 : (0))                                                                  \\\r\n          : (1)))\r\n\r\n#define ssDisableSystemWithTid(S, element, tid)                                         \\\r\n    (((S)->callSys.fcns[3 * ssGetOutputPortWidth((S), 0) + (element)] != NULL)          \\\r\n         ? ((*(S)->callSys.fcns[3 * ssGetOutputPortWidth((S), 0) + (element)])(         \\\r\n                (S)->callSys.args1[(element)], (S)->callSys.args2[(element)], (tid))    \\\r\n                ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\r\n                : (0))                                                                  \\\r\n         : (1))\r\n#else /* #if defined(RSIM_WITH_SL_SOLVER) */\r\n\r\n/**\r\n * @brief ssEnableSystemWithTid\r\n *\r\n * Enable a function-call subsystem connected to this S-function\r\n * @param    S         SimStruct representing an S-Function block.\r\n * @param    element   Index of the output port element corresponding to the function-call\r\n * subsystem.\r\n * @param    tid       Task ID.\r\n */\r\n#define ssEnableSystemWithTid(S, element, tid)                                          \\\r\n    (((S)->callSys.fcns[ssGetOutputPortWidth((S), 0) + (element)] != NULL)              \\\r\n         ? ((*(S)->callSys.fcns[ssGetOutputPortWidth((S), 0) + (element)])(             \\\r\n                (S)->callSys.args1[(element)], (S)->callSys.args2[(element)], (tid))    \\\r\n                ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\r\n                : (0))                                                                  \\\r\n         : (1))\r\n\r\n/**\r\n * @brief ssDisableSystemWithTid\r\n *\r\n * Disable a function-call subsystem connected to this S-function block\r\n * @param    S         SimStruct representing an S-Function block.\r\n * @param    element   Index of the output port element corresponding to the function-call\r\n * subsystem.\r\n * @param    tid       Task ID.\r\n */\r\n#define ssDisableSystemWithTid(S, element, tid)                                         \\\r\n    (((S)->callSys.fcns[2 * ssGetOutputPortWidth((S), 0) + (element)] != NULL)          \\\r\n         ? ((*(S)->callSys.fcns[2 * ssGetOutputPortWidth((S), 0) + (element)])(         \\\r\n                (S)->callSys.args1[(element)], (S)->callSys.args2[(element)], (tid))    \\\r\n                ? ((ssGetErrorStatus(S) == NULL) && (ssGetLocalErrorStatus(S) == NULL)) \\\r\n                : (0))                                                                  \\\r\n         : (1))\r\n#endif /* #if defined(RSIM_WITH_SL_SOLVER) */\r\n#endif /* #if SS_RT */\r\n\r\n\r\n/**\r\n * @brief ssGetCallSystemNumFcnCallDestinations\r\n *\r\n * Get the number of function-call destinations.\r\n * @param    S         SimStruct representing an S-Function block.\r\n * @param    elemIdx   The zero-based element index that is output on the first output port\r\n * @return   int_T\r\n */\r\n#define ssGetCallSystemNumFcnCallDestinations(S, elemIdx) \\\r\n    _ssGetCallSystemNumFcnCallDestinations(S, elemIdx)\r\n\r\n\r\n/**\r\n * @brief ssGetExplicitFCSSCtrl\r\n *\r\n * Determine whether this S-function explicitly enables and disables the function-call subsystems\r\n * that it invokes\r\n * @param    S         SimStruct representing an S-Function block.\r\n * @return   The uint_T 1 if S explicitly enables or disables the function-control subsystem that it\r\n * invokes. Otherwise, returns 0.\r\n */\r\n#define ssGetExplicitFCSSCtrl(S) (S)->sizes.flags.explicitFCSSCtrl /*   (unsigned int_T: 1) */\r\n\r\n/**\r\n * @brief ssSetExplicitFCSSCtrl\r\n *\r\n * Specify whether this S-function explicitly enables and disables the function-call subsystem that\r\n * it calls\r\n * @param    S         SimStruct representing an S-Function block.\r\n * @param    n         1 if this S-function explicitly enables and disables the function-call\r\n * subsystems it enables\r\n */\r\n#define ssSetExplicitFCSSCtrl(S, n) (S)->sizes.flags.explicitFCSSCtrl = (n)\r\n\r\n/** @} */ /* end of FcnCallSubsystem */\r\n\r\n/** @defgroup ModelReference  Model Reference\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Model Reference *\r\n *======================================*/\r\n/**\r\n * @brief ssRTWGenIsModelReferenceRTWTarget\r\n *\r\n * Determine if the model reference Simulink Coder target is generating\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @return   The Boolean value true if the model reference Simulink Coder target is building.\r\n * Returns false if the model reference simulation target is building.\r\n */\r\n#if SS_SIM\r\n#define ssRTWGenIsModelReferenceRTWTarget(S) \\\r\n    (ssGetSimMode(S) == SS_SIMMODE_RTWGEN && \\\r\n     ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_MODELREFERENCE_RTW_TARGET))\r\n#else\r\n#define ssRTWGenIsModelReferenceRTWTarget(S) (false)\r\n#endif\r\n\r\n/**\r\n * @brief ssRTWGenIsModelReferenceSimTarget\r\n *\r\n * Determine if the model reference simulation target is generating\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @return   The Boolean value true if the model reference Simulation target is building. Returns\r\n * false if the model reference Simulink Coder target is building.\r\n */\r\n#if SS_SIM\r\n#define ssRTWGenIsModelReferenceSimTarget(S) \\\r\n    (ssGetSimMode(S) == SS_SIMMODE_RTWGEN && \\\r\n     ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_MODELREFERENCE_SIM_TARGET))\r\n#else\r\n#define ssRTWGenIsModelReferenceSimTarget(S) (false)\r\n#endif\r\n\r\n\r\n\r\n/**\r\n * @brief ssSetModelReferenceNormalModeSupport\r\n *\r\n * Specify if S-function can be used in referenced model simulating in normal mode\r\n * @param    S    SimStruct representing an S-Function block.\r\n * @param    n    Flag for normal mode simulation support when the S-Function block is used in a\r\n * referenced model.\r\n */\r\n#define ssSetModelReferenceNormalModeSupport(S, n) (S)->sizes.flags.modelRefNormalModeSupport = (n)\r\n\r\n/**\r\n * @brief ssSetModelReferenceSampleTimeDefaultInheritance\r\n *\r\n * Specify that a referenced model containing this S-function can inherit its sample time from its\r\n * parent model\r\n * @param    S    SimStruct representing an S-Function block.\r\n */\r\n#define ssSetModelReferenceSampleTimeDefaultInheritance(S) \\\r\n    (S)->sizes.flags.modelRefTsInhSupLevel = USE_DEFAULT_FOR_DISCRETE_INHERITANCE\r\n\r\n/**\r\n * @brief ssSetModelReferenceSampleTimeDisallowInheritance\r\n *\r\n * Specify that the use of this S-function in a referenced model prevents the referenced model from\r\n * inheriting its sample time from its parent model\r\n * @param    S    SimStruct representing an S-Function block.\r\n */\r\n#define ssSetModelReferenceSampleTimeDisallowInheritance(S) \\\r\n    (S)->sizes.flags.modelRefTsInhSupLevel = DISALLOW_SAMPLE_TIME_INHERITANCE\r\n\r\n/**\r\n * @brief ssSetModelReferenceSampleTimeInheritanceRule\r\n *\r\n * Specify whether use of this S-function in a referenced model prevents the referenced model\r\n * from inheriting its sample time from its parent model\r\n * @param    S    SimStruct representing an S-Function block.\r\n * @param    n    Rule for allowing referenced models containing this S-function to inherit\r\n * their sample times from the parent model.\r\n */\r\n#define ssSetModelReferenceSampleTimeInheritanceRule(S, n) \\\r\n    (S)->sizes.flags.modelRefTsInhSupLevel = (n)\r\n\r\n\r\n/** @} */ /* end of ModelReference */\r\n\r\n/** @defgroup Buses  Buses\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Buses *\r\n *======================================*/\r\n\r\n#if SS_SIM\r\n#define ssGetDataTypeAccess(S) ((S)->mdlInfo->dataTypeAccess)\r\n#else\r\n#define ssGetDataTypeAccess(S) ssGetDataTypeAccess_cannot_be_used_in_RTW\r\n#endif\r\n\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n/**\r\n * @brief ssGetBusElementComplexSignal\r\n *\r\n * Get the signal complexity for a bus element\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    busTypeID   The bus data type identifier that represents the bus signal\r\n * @param    elemIdx     The zero-based bus element index\r\n * @return   CSignal_T\r\n */\r\n#define ssGetBusElementComplexSignal(S, busTypeID, elemIdx) \\\r\n    (dtaGetDataTypeElementSignalType(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\r\n\r\n/**\r\n * @brief ssGetBusElementDataType\r\n *\r\n * Get the data type identifier for a bus element\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    busTypeID   The bus data type identifier that represents the bus signal\r\n * @param    elemIdx     The zero-based bus element index\r\n * @return   int_T\r\n */\r\n#define ssGetBusElementDataType(S, busTypeID, elemIdx) \\\r\n    (dtaGetDataTypeElementDataType(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\r\n\r\n/**\r\n * @brief ssGetBusElementDimensions\r\n *\r\n * Get the dimensions of a bus element\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    busTypeID   The bus data type identifier that represents the bus signal\r\n * @param    elemIdx     The zero-based bus element index\r\n * @return   const int_T*\r\n */\r\n#define ssGetBusElementDimensions(S, busTypeID, elemIdx) \\\r\n    (dtaGetDataTypeElementDimensions(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\r\n\r\n\r\n/**\r\n * @brief ssGetBusElementName\r\n *\r\n * Get the name of a bus element\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    busTypeID   The bus data type identifier that represents the bus signal\r\n * @param    elemIdx     The zero-based bus element index\r\n * @return   const char*\r\n */\r\n#define ssGetBusElementName(S, busTypeID, elemIdx) \\\r\n    (dtaGetDataTypeElementName(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\r\n\r\n/**\r\n * @brief ssGetBusElementNumDimensions\r\n *\r\n * Get the number of dimensions for a bus element\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    busTypeID   The bus data type identifier that represents the bus signal\r\n * @param    elemIdx     The zero-based bus element index\r\n * @return   int_T\r\n */\r\n#define ssGetBusElementNumDimensions(S, busTypeID, elemIdx)                                \\\r\n    (dtaGetDataTypeElementNumDimensions(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), \\\r\n                                        (elemIdx)))\r\n\r\n/**\r\n * @brief ssGetBusElementOffset\r\n *\r\n * Get the offset from the start of the bus data type to a bus element\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    busTypeID   The bus data type identifier that represents the bus signal\r\n * @param    elemIdx     The zero-based bus element index\r\n * @return   int_T\r\n */\r\n#define ssGetBusElementOffset(S, busTypeID, elemIdx) \\\r\n    (dtaGetDataTypeElementOffset(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID), (elemIdx)))\r\n\r\n\r\n/**\r\n * @brief ssGetNumBusElements\r\n *\r\n * Get the number of elements in a bus signal\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    busTypeID   The bus data type identifier that represents the bus signal\r\n * @return   int_T\r\n */\r\n#define ssGetNumBusElements(S, busTypeID) \\\r\n    (dtaGetDataTypeNumElements(ssGetDataTypeAccess(S), ssGetPath(S), (busTypeID)))\r\n\r\n\r\n/**\r\n * @brief ssGetSFcnParamName\r\n *\r\n * Get the value of a block parameter for an S-function block\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    pIdx        The zero-based index into the S-function parameters\r\n * @param    result      Value of the parameter specified in the block dialog box\r\n */\r\n#define ssGetSFcnParamName(S, pIdx, result)                                      \\\r\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_PARAM_NAME, pIdx, (result)) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n\r\n\r\n/**\r\n * @brief ssIsDataTypeABus\r\n *\r\n * Determine whether a data type identifier represents a bus signal\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    typeID      The data type identifier that represents a signal\r\n * @return   int_T       1 for bus, 0 for non-bus, and -1 when error occurs\r\n */\r\n#define ssIsDataTypeABus(S, typeID) \\\r\n    (dtaGetDataTypeIsBus(ssGetDataTypeAccess(S), ssGetPath(S), typeID))\r\n\r\n/**\r\n * @brief ssSetBusInputAsStruct\r\n *\r\n * Specify whether to convert the input bus signal for an S-function from virtual to nonvirtual\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    pIdx        The zero-based index of the input port of the S-function block\r\n * @param    value       True, if the input signal is a virtual bus and should be converted to a\r\n * nonvirtual bus; false otherwise\r\n */\r\n#define ssSetBusInputAsStruct(S, pIdx, value)                                             \\\r\n    {                                                                                     \\\r\n        boolean_T tmp = value;                                                            \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_BUS_INPUT_AS_STRUCT, pIdx, &tmp) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                   \\\r\n    }\r\n/**\r\n * @brief ssSetBusOutputAsStruct\r\n *\r\n * Specify whether the output bus signal from an S-function must be virtual or nonvirtual\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    pIdx        The zero-based index of the output port of the S-function block\r\n * @param    value       True, if the output signal is a nonvirtual bus and should be converted to a\r\n * virtual bus; false otherwise\r\n */\r\n#define ssSetBusOutputAsStruct(S, pIdx, value)                                             \\\r\n    {                                                                                      \\\r\n        boolean_T tmp = value;                                                             \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_BUS_OUTPUT_AS_STRUCT, pIdx, &tmp) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                    \\\r\n    }\r\n/**\r\n * @brief ssSetBusOutputObjectName\r\n *\r\n * Specify the name of the bus object that defines the structure and type of the output bus signal\r\n * @param    S           SimStruct representing an S-Function block\r\n * @param    pIdx        The zero-based index of the output port of the S-function block\r\n * @param    name        The name of the bus object\r\n */\r\n#define ssSetBusOutputObjectName(S, pIdx, name)                                          \\\r\n    _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SET_BUS_OUTPUT_OBJECT_NAME, pIdx, name) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n\r\n#else\r\n\r\n#define ssGetBusElementComplexSignal(S, busTypeID, elemIdx) \\\r\n    ssGetBusElementComplexSignal_cannot_be_used_in_RTW\r\n\r\n#define ssGetBusElementDataType(S, busTypeID, elemIdx) ssGetBusElementDataType_cannot_be_used_in_RTW\r\n\r\n#define ssGetBusElementDimensions(S, busTypeID, elemIdx) \\\r\n    ssGetBusElementDimensions_cannot_be_used_in_RTW\r\n\r\n#define ssGetBusElementName(S, busTypeID, elemIdx) ssGetBusElementName_cannot_be_used_in_RTW\r\n\r\n#define ssGetBusElementNumDimensions(S, busTypeID, elemIdx) \\\r\n    ssGetBusElementNumDimensions_cannot_be_used_in_RTW\r\n\r\n#define ssGetBusElementOffset(S, busTypeID, elemIdx) ssGetBusElementOffset_cannot_be_used_in_RTW\r\n\r\n#define ssGetNumBusElements(S, busTypeID) ssGetNumBusElements_cannot_be_used_in_RTW\r\n\r\n#define ssGetSFcnParamName(S, pIdx, result)\r\n\r\n#define ssIsDataTypeABus(S, typeID) ssIsDataTypeABus_cannot_be_used_in_RTW\r\n\r\n#define ssSetBusInputAsStruct(S, pIdx, value)\r\n\r\n#define ssSetBusOutputAsStruct(S, pIdx, value)\r\n\r\n#define ssSetBusOutputObjectName(S, pIdx, name)\r\n\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssSetCallSystemOutput\r\n *\r\n * Specify that an output port is issuing a function call.\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    element     Index of the element of the first output port that is issuing a function\r\n * call.\r\n */\r\n#define ssSetCallSystemOutput(S, element) (S)->callSys.outputs[element] = ((int_T)1)\r\n\r\n\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n#if SS_SIM\r\n/**\r\n * @brief ssRegisterTypeFromParameter\r\n *\r\n * Register a data type that a parameter in the Simulink data type table specifies\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    idx         The zero-based index of the S-function parameter that specifies the bus\r\n * object name\r\n * @return   id          A pointer to an int_T that contains the Simulink ID of the newly registered\r\n * data type\r\n */\r\n#define ssRegisterTypeFromParameter(S, idx, id)                                               \\\r\n    {                                                                                         \\\r\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REGISTER_TYPE_FROM_PARAMETER, (idx), (id)) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                       \\\r\n    }\r\n/**\r\n * @brief ssRegisterTypeFromParameter\r\n *\r\n * Register a custom data type from a Simulink.AliasType, Simulink.NumericType, or Simulink.Bus\r\n * object.\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    n           Name of the Simulink object to assign to the custom data type.\r\n * @return   id          An integer whose value is the numeric data type identifier after the call\r\n * to ssRegisterTypeFromNamedObject\r\n */\r\n#define ssRegisterTypeFromNamedObject(S, n, id)                                        \\\r\n    {                                                                                  \\\r\n        ssRegisterTypeFromNameType _slRegisterTypeFromNameInfo;                        \\\r\n        _slRegisterTypeFromNameInfo.name = (n);                                        \\\r\n        _slRegisterTypeFromNameInfo.dataTypeId = (id);                                 \\\r\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REGISTER_TYPE_FROM_NAMED_OBJECT, 0, \\\r\n                                        (void*)&_slRegisterTypeFromNameInfo)           \\\r\n            _ssSafelyCallGenericFcnEnd;                                                \\\r\n    }\r\n\r\n#else\r\n#define ssRegisterTypeFromParameter(S, idx, id)\r\n#define ssRegisterTypeFromNamedObject(S, name, id)\r\n#endif\r\n#endif\r\n\r\n/** @} */ /* end of Buses */\r\n\r\n/** @defgroup SimulationInformation  Simulation Information\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Simulation Information *\r\n *======================================*/\r\n\r\n/**\r\n * @brief ssSetStateAbsTol\r\n *\r\n * Set the absolute tolerance used by a variable-step solver for a specific S-function continuous\r\n * state.\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    idx         An index representing an S-function continuous state.\r\n * @param    val         The value of the absolute tolerance.\r\n */\r\n#define ssSetStateAbsTol(S, idx, val) _ssSetStateAbsTol(S, idx, val)\r\n\r\n/**\r\n * @brief ssGetStateAbsTol\r\n *\r\n * Get the absolute tolerance used by the variable-step solver for a specified state\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    idx         An index representing an S-function continuous state.\r\n */\r\n#define ssGetStateAbsTol(S, idx) (const real_T)(((S)->states.statesInfo2)->absTol[idx])\r\n\r\n/**\r\n * @brief ssGetBlockReduction\r\n *\r\n * Determine whether a block has requrested block reduction before the simulation has begun\r\n * and whether it has actually been reduced after the simulation loop has begun\r\n * @param    S           SimStruct representing an S-Function block.\r\n */\r\n#define ssGetBlockReduction(S) (S)->sizes.flags.blockReduction /*   (unsigned int_T: 1) */\r\n\r\n/**\r\n * @brief ssSetBlockReduction\r\n *\r\n * Request that the Simulink engine attempt to reduce a block\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    n           If not zero, the Simulink engine should attempt to reduce this block.\r\n */\r\n#define ssSetBlockReduction(S, n) (S)->sizes.flags.blockReduction = (n)\r\n\r\n/**\r\n * @brief ssSetOperatingPointCompliance\r\n *\r\n * Specify the behavior of a Simulink S-function when saving and restoring the operating point of a\r\n * model containing the given S-function\r\n * @param    S           SimStruct representing an S-function block.\r\n * @param    set         Define how to treat an S-function simulation state when saving and\r\n * restoring the model operating point.\r\n */\r\n#define ssSetOperatingPointCompliance(S, set) (S)->sizes.flags.simStateCompliance = (set)\r\n\r\n/**\r\n * @brief ssSetOperatingPointVisibility\r\n *\r\n * Specify whether to make the S-function's simulation state visible in the operating point of the\r\n * model.\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    vis         Option to specify the visibility of the S-function simulation state.\r\n * The default is false; the simulation state is hidden.\r\n */\r\n#define ssSetOperatingPointVisibility(S, vis) (S)->sizes.flags.simStateVisibility = (vis)\r\n\r\n/**\r\n * @brief ssGetGetOperatingPointFcn\r\n *\r\n * Get the mdlGetOperatingPoint function pointer from simstruct\r\n * model.\r\n * @param    S           SimStruct representing an S-Function block.\r\n */\r\n #define ssGetGetOperatingPointFcn(S) (S)->states.modelMethods2->modelMethods4->mdlGetOperatingPoint\r\n\r\n /**\r\n * @brief ssGetSetOperatingPointFcn\r\n *\r\n * Get the mdlSetOperatingPoint function pointer from simstruct\r\n * model.\r\n * @param    S           SimStruct representing an S-Function block.\r\n */\r\n #define ssGetSetOperatingPointFcn(S) (S)->states.modelMethods2->modelMethods4->mdlSetOperatingPoint\r\n\r\n/**\r\n * @brief ssSetSkipContStatesConsistencyCheck\r\n *\r\n * Ask Simulink engine to reset solver\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    val         Boolean value (boolean_T) telling Simulink to skip the continuous state\r\n * consistency check.\r\n */\r\n#define ssSetSkipContStatesConsistencyCheck(S, val) \\\r\n    ((S)->states.flags.skipContStatesConsistencyCheck = ((val) ? 1U : 0U))\r\n\r\n/**\r\n * @brief ssGetSimStatus\r\n *\r\n * Get the current simulation status of an S-function block\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    result      SS_SimStatus object that returns the current simulation status.\r\n */\r\n#define ssGetSimStatus(S, result)                                               \\\r\n    {                                                                           \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_GET_SIM_STATUS, 0, result) \\\r\n            _ssSafelyCallGenericFcnEnd;                                         \\\r\n    }\r\n\r\n/**\r\n * @brief ssIsExternalSim\r\n *\r\n * Determine if the model is running in the external mode\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @return   The Boolean value true if the model is running in external mode.\r\n * Returns false otherwise. Note: if ssGetSimMode returns \"external\", the result is identical to\r\n * that of ssIsExternalSim.\r\n */\r\n#if SS_SIM\r\n#define ssIsExternalSim(S) \\\r\n    (ssGetSimMode(S) == SS_SIMMODE_EXTERNAL && ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_RTW_CODE))\r\n#else\r\n#define ssIsExternalSim(S) (false)\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssRTWGenIsAccelerator\r\n *\r\n * Determine if the model is running in Accelerator mode.\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @return   The Boolean value true if the model has compiled or is compiling for Accelerator mode\r\n * simulation. Returns false otherwise.\r\n */\r\n#if SS_SIM\r\n#define ssRTWGenIsAccelerator(S) \\\r\n    (ssGetSimMode(S) == SS_SIMMODE_RTWGEN && ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_ACCELERATOR))\r\n#else\r\n#define ssRTWGenIsAccelerator(S) (false)\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssIsRapidAcceleratorActive\r\n *\r\n * Determine whether the model is running in Rapid Accelerator mode.\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @return   The Boolean value true if the model is being built or simulated in the Rapid\r\n * Accelerator mode. Returns false otherwise.\r\n */\r\n#define ssIsRapidAcceleratorActive(S)                                        \\\r\n    ((!ssGetParentSS(S)) ? ((S)->sizes.flags.isRapidAcceleratorActive == 1U) \\\r\n                         : ((ssGetParentSS(S))->sizes.flags.isRapidAcceleratorActive == 1U))\r\n\r\n/**\r\n * @brief ssGetT\r\n *\r\n * Get the current simulation time\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @return A value of type time_T indicating the current simulation time.\r\n */\r\n#define ssGetT(S) (S)->mdlInfo->t[0] /*   (time_T)      */\r\n\r\n/**\r\n * @brief ssGetTStart\r\n *\r\n * Get the simulation start time\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @return A value of type time_T.\r\n */\r\n#define ssGetTStart(S) (S)->mdlInfo->tStart /*   (time_T)      */\r\n\r\n/**\r\n * @brief ssGetTFinal\r\n *\r\n * Get the simulation stop time\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @return A value of type time_T.\r\n */\r\n#define ssGetTFinal(S) (S)->mdlInfo->tFinal /*   (time_T)      */\r\n\r\n\r\n/**\r\n * @brief ssGetStopRequested\r\n *\r\n * Get the value of the simulation stop requested flag\r\n * @param    S           SimStruct representing an S-Function block or a Simulink model.\r\n * @return   The int_T value of the simulation stop requested flag.\r\n */\r\n#define ssGetStopRequested(S) (S)->mdlInfo->stopRequested /*   (int_T)   */\r\n/**\r\n * @brief ssSetStopRequested\r\n *\r\n * Set the simulation stop requested flag\r\n * @param    S           SimStruct representing an S-Function block or a Simulink model\r\n * @param    val         Boolean value (int_T) specifying whether stopping the simulation has been\r\n * requested (1) or not (0).\r\n */\r\n#if SS_SFCN && SS_SFCN_FOR_SIM\r\n#define ssSetStopRequested(S, val)                                                        \\\r\n    {                                                                                     \\\r\n        boolean_T val2 = (val);                                                           \\\r\n        _ssSafelyCallConstGenericFcnStart(S)((((const SimStruct*)(S))),                   \\\r\n                                             GEN_FCN_SET_STOP_REQUESTED_SFUN, 0, &(val2)) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                   \\\r\n        (S)->mdlInfo->stopRequested = (val);                                              \\\r\n    }\r\n#else\r\n#define ssSetStopRequested(S, val) (S)->mdlInfo->stopRequested = (val)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetSimMode\r\n *\r\n * Get the simulation mode of an S-Function block\r\n * @param    S           SimStruct representing an S-Function block or a Simulink model\r\n * @return   An enumerated value of type SS_SimMode\r\n */\r\n#define ssGetSimMode(S) (S)->mdlInfo->simMode /* (SS_SimMode)    */\r\n\r\n/**\r\n * @brief ssGetSolverName\r\n *\r\n * Get the name of the solver being used to solve the S-function\r\n * @param    S           SimStruct representing an S-Function block or a Simulink model\r\n * @return   A pointer (char_T *) to the name of the solver being used.\r\n */\r\n#define ssGetSolverName(S) (S)->mdlInfo->solverName /*   (char_T *)    */\r\n\r\n\r\n/**\r\n * @brief ssIsVariableStepSolver\r\n *\r\n * Determine if a variable-step solver is being used to solve the S-function\r\n * @param    S           SimStruct representing an S-Function block or a Simulink model\r\n * @return   The Boolean value true if the solver being used to solve S is a variable-step solver.\r\n * Otherwise, returns false.\r\n */\r\n#define ssIsVariableStepSolver(S) (S)->mdlInfo->variableStepSolver /*   (int_T *)  */\r\n\r\n\r\n/**\r\n * @brief ssSetSolverNeedsReset\r\n *\r\n * Ask Simulink engine to reset solver\r\n * @param    S           SimStruct representing an S-Function block or a Simulink model.\r\n */\r\n#define ssSetSolverNeedsReset(S) (S)->mdlInfo->solverNeedsReset = ((int_T)1)\r\n\r\n\r\n/**\r\n * @brief ssSetContTimeOutputInconsistentWithStateAtMajorStep\r\n *\r\n * Notify Simulink that the block's continuous outputs have become inconsistent since the last call\r\n * to mdlOutputs (even though time and inputs many have not changed). This call will force Simulink\r\n * to re-evaluate this block's continuous outputs at the beginning of the next integration step.\r\n *\r\n * @param    S           SimStruct representing an S-Function block or a Simulink model.\r\n */\r\n#define ssSetContTimeOutputInconsistentWithStateAtMajorStep(S) \\\r\n    (S)->mdlInfo->mdlFlags.cTimeOutputInconsistentWithStateAtMajorStep = 1U\r\n\r\n\r\n/**\r\n * @brief ssSetContTimeOutputInconsistentWithStateAtMajorStep\r\n *\r\n * Notify Simulink that the block's continuous states have changed at the current major time\r\n * step. This call will force Simulink to reset solver data based on cached values of the continuous\r\n * states at the beginning of the next integration step.\r\n *\r\n * @param    S           SimStruct representing an S-Function block or a Simulink model.\r\n */\r\n#define ssSetBlockStateForSolverChangedAtMajorStep(S) \\\r\n    (S)->mdlInfo->mdlFlags.blockStateForSolverChangedAtMajorStep = 1U\r\n\r\n\r\n/**\r\n * @brief ssGetSolverMode\r\n *\r\n * Get solver mode\r\n * @param    S           SimStruct representing an S-Function block or a Simulink model.\r\n */\r\n#define ssGetSolverMode(S) (S)->mdlInfo->solverMode /*   (SolverMode)   */\r\n\r\n\r\n/**\r\n * @brief ssGetFixedStepSize\r\n *\r\n * Get the fixed step size of the model containing the S-function.\r\n * @param    S           SimStruct representing an S-Function block.\r\n */\r\n#define ssGetFixedStepSize(S) (S)->mdlInfo->fixedStepSize /*   (time_T)      */\r\n\r\n/**\r\n * @brief ssIsFirstInitCond\r\n *\r\n * Determine whether the simulation time is equal to the start time.\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @return   The Boolean value true if the current simulation time is equal to the simulation start\r\n * time. Otherwise, returns false.\r\n */\r\n#define ssIsFirstInitCond(S) (!((ssGetRootSS(S)->mdlInfo->mdlFlags).firstInitCondCalled))\r\n\r\n#if !defined(ENABLE_SLEXEC_SSBRIDGE)\r\n\r\n#define ssGetGlobalInitialStatesAvailable(S) 0\r\n\r\n#endif\r\n\r\n/**\r\n * @brief ssIsMinorTimeStep\r\n *\r\n * Determine whether the simulation is in a minor step\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @return   The Boolean value true if the simulation is in a minor time step. Otherwise, returns\r\n * false.\r\n */\r\n#define ssIsMinorTimeStep(S) ((S)->mdlInfo->simTimeStep == MINOR_TIME_STEP) /*  (int_T)    */\r\n\r\n\r\n/**\r\n * @brief ssIsMajorTimeStep\r\n *\r\n * Determine whether the simulation is in a major step\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @return   The Boolean value true if the simulation is in a major time step. Otherwise, returns\r\n * false.\r\n */\r\n#define ssIsMajorTimeStep(S) ((S)->mdlInfo->simTimeStep == MAJOR_TIME_STEP) /*  (int_T)    */\r\n\r\n\r\n/**\r\n * @brief ssSetNeedAbsoluteTime\r\n *\r\n * Register whether the block requires  absolute time\r\n * @param    S          SimStruct representing an S-Function block\r\n * @param    n          Boolean flag indicating whether the block must use absolute time\r\n *\r\n */\r\n#define ssSetNeedAbsoluteTime(S, n) (S)->sizes.flags.needAbsoluteTime = (n)\r\n\r\n\r\n/**\r\n * @brief ssSetTimeSource\r\n *\r\n * Register time source for an asynchronous task\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    timeSource    Source of time used by the asynchronous task created by the block\r\n * for the asynchronous task the S-function registers\r\n *    SS_TIMESOURCE_BASERATE\r\n *    SS_TIMESOURCE_SELF\r\n *    SS_TIMESOURCE_CALLER\r\n *    SS_TIMESOURCE_SELF_INTERNAL\r\n */\r\n#if SS_SFCN\r\n\r\n#define ssSetTimeSource(S, timeSource)                                            \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_TIME_SOURCE, timeSource, NULL) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssGetTaskTime\r\n *\r\n * Get the current time for the current task.\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    sti         Index of the sample time corresponding to the task for which the current\r\n * time is to be returned.\r\n * @return   A value of type time_T.\r\n */\r\n#define ssGetTaskTime(S, sti) \\\r\n    (S)->mdlInfo->t[ssIsTIDInStInfo(S, sti) ? ssGetSampleTimeTaskID(S, sti) : 0] /*  (time_T)   */\r\n\r\n\r\n/** @} */ /* end of SimulationInformation */\r\n\r\n/** @defgroup RunTimeParams  Run-Time Parameters\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Run-Time Parameters *\r\n *======================================*/\r\n\r\n/**\r\n * @brief ssGetNumRunTimeParams\r\n *\r\n * Get the number of run-time parameters created by this S-function\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @return An int_T value indicating the number of run-time parameters.\r\n */\r\n#define ssGetNumRunTimeParams(S) (S)->sfcnParams.numRtp.numRtp\r\n\r\n/**\r\n * @brief ssGetRunTimeParamInfo\r\n *\r\n * Get the attributes of a run-time parameter\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @param  idx         Index of a run-time parameter.\r\n * @return A pointer to the ssParamRec describing the attributes of the run-time parameter specified\r\n * by the index param.\r\n */\r\n#define ssGetRunTimeParamInfo(S, idx) (S)->sfcnParams.rtp[idx]\r\n\r\n\r\n/**\r\n * @brief ssRegAllTunableParamsAsRunTimeParams\r\n *\r\n * Register all tunable parameters as run-time parameters\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @param  ms          Array of names for the run-time parameters.\r\n */\r\n#define ssRegAllTunableParamsAsRunTimeParams(S, nms)                                   \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REG_ALL_TUNE_PRM_AS_RTP, 0, (void*)nms) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n\r\n\r\n\r\n/**\r\n * @brief ssRegDlgParamAsRunTimeParam\r\n *\r\n * Register a dialog parameter as a run-time parameter\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    dlgIdxArg   Index of the dialog parameter.\r\n * @param    rtIdxArg    Index of the run-time parameter.\r\n * @param    nameArg     Name of the run-time parameter.\r\n * @dtIdArg  dtIdArg     Value of type DTypeId that specifies the data type of the run-time\r\n * parameter.\r\n */\r\n#if SS_SFCN && SS_SIM\r\n#define ssRegDlgParamAsRunTimeParam(S, dlgIdxArg, rtIdxArg, nameArg, dtIdArg)     \\\r\n    {                                                                             \\\r\n        ssRTPRegInfoWithType _slConvTypeAndRegParamInfo;                          \\\r\n        _slConvTypeAndRegParamInfo.dlgIdx = (dlgIdxArg);                          \\\r\n        _slConvTypeAndRegParamInfo.rtIdx = (rtIdxArg);                            \\\r\n        _slConvTypeAndRegParamInfo.name = (nameArg);                              \\\r\n        _slConvTypeAndRegParamInfo.dtId = (dtIdArg);                              \\\r\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REG_AND_CNV_RUN_TIME_PARAM, 0, \\\r\n                                        (void*)&_slConvTypeAndRegParamInfo)       \\\r\n            _ssSafelyCallGenericFcnEnd;                                           \\\r\n    }\r\n#endif\r\n\r\n\r\n\r\n/**\r\n * @brief ssSetNumRunTimeParams\r\n *\r\n * Specify the number of run-time parameters created by this S-function\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    num         Number of run-time parameters.\r\n */\r\n#if SS_SFCN\r\n#if SS_RTW\r\n#define ssSetNumRunTimeParams(S, num) _ssSetNumRunTimeParams(S, num)\r\n#else\r\n#define ssSetNumRunTimeParams(S, num)                                              \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_SET_NUM_RUN_TIME_PARAMS, num, NULL) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n#endif\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssSetRunTimeParamInfo\r\n *\r\n * Specify the attributes of a run-time parameter\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    idx         Index of a run-time parameter\r\n * @param    p           ssParamRec structure containing the attributes of the run-time parameter.\r\n */\r\n#if SS_SFCN\r\n#if SS_RTW\r\n#define ssSetRunTimeParamInfo(S, idx, p) _ssSetRunTimeParamInfo(S, idx, p)\r\n#else\r\n#define ssSetRunTimeParamInfo(S, idx, p)                                          \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_REG_RUN_TIME_PARAM, idx, (void*)p) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n#endif\r\n#endif\r\n\r\n\r\n#if SS_SFCN && SS_SIM\r\n/**\r\n * @brief ssUpdateAllTunableParamsAsRunTimeParams\r\n *\r\n * Update the values of run-time parameters to be the same as those of the corresponding tunable\r\n * dialog parameters.\r\n * @param    S           SimStruct representing an S-Function block.\r\n */\r\n#define ssUpdateAllTunableParamsAsRunTimeParams(S)                                  \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_UPDATE_ALL_TUNE_PRM_AS_RTP, 0, NULL) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n\r\n\r\n\r\n/**\r\n * @brief ssUpdateDlgParamAsRunTimeParam\r\n *\r\n * Update a run-time parameter that corresponds to a dialog parameter.\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    rtIdxArg    Index of the run-time parameter.\r\n */\r\n#define ssUpdateDlgParamAsRunTimeParam(S, rtIdxArg)                                           \\\r\n    {                                                                                         \\\r\n        _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_UPDATE_AND_CNV_RUN_TIME_PARAM, (rtIdxArg), \\\r\n                                        NULL) _ssSafelyCallGenericFcnEnd;                     \\\r\n    }\r\n\r\n\r\n/**\r\n * @brief ssUpdateRunTimeParamData\r\n *\r\n * Update the value of a run-time parameter\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    idx         Index of the run-time parameter.\r\n * @param    d           New value of the parameter.\r\n */\r\n#define ssUpdateRunTimeParamData(S, idx, d) ((S)->sfcnParams.rtp[idx])->data = (d)\r\n\r\n/**\r\n * @brief ssUpdateRunTimeParamInfo\r\n *\r\n * Update the attributes of a run-time parameter\r\n * @param    S           SimStruct representing an S-Function block.\r\n * @param    idx         Index of the run-time parameter.\r\n * @param    p           Attributes of the run-time parameter.\r\n */\r\n#define ssUpdateRunTimeParamInfo(S, idx, p)                                          \\\r\n    _ssSafelyCallGenericFcnStart(S)(S, GEN_FCN_UPDATE_RUN_TIME_PARAM, idx, (void*)p) \\\r\n        _ssSafelyCallGenericFcnEnd\r\n\r\n#endif /* __SS_SFCN && SS_SIM__ */\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssSetRuntimeThreadSafetyCompliance\r\n *\r\n * Specify that the S-function is run-time thread-safe.\r\n * @param    S             SimStruct representing an S-Function block.\r\n * @param    val           One of the following enumerated values that indicates if the\r\n * S-function is run-time thread-safe or not or unknown:\r\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE\r\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_FALSE\r\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_UNKNOWN\r\n */\r\n#define ssSetRuntimeThreadSafetyCompliance(S, val) \\\r\n    (S)->blkInfo.sfcnFlags.runtimeThreadSafetyCompliance = (val)\r\n#endif\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetRuntimeThreadSafetyCompliance\r\n *\r\n * Determine whether the S-function is run-time thread-safe.\r\n * @return   One of the following enumerated values that indicates if the\r\n * S-function is run-time thread-safe or not or unknown:\r\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_TRUE\r\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_FALSE\r\n *     RUNTIME_THREAD_SAFETY_COMPLIANCE_UNKNOWN\r\n */\r\n#define ssGetRuntimeThreadSafetyCompliance(S) \\\r\n    ((RuntimeThreadSafetyCompliance)((S)->blkInfo.sfcnFlags.runtimeThreadSafetyCompliance))\r\n#endif\r\n\r\n/** @} */ /* end of RunTimeParams */\r\n\r\n/** @defgroup StateWorkVector  State and Work Vector\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * State and Work Vector *\r\n *======================================*/\r\n/**\r\n * @brief ssSetNumDWork\r\n *\r\n * Specify the number of data type work vectors used by a block\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  num       Number of data type work vectors.\r\n * @return The Boolean value true if nDWork is zero or a positive integer; otherwise, false.\r\n */\r\n#if !SS_SFCN_LEVEL_1\r\n#if SS_SFCN_FOR_SIM\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetNumDWork(S, num)                                                            \\\r\n    (((S)->blkInfo.blkInfo2->blkInfoSLSize->regDataType.setNumDWorkFcn != NULL)          \\\r\n         ? (*(S)->blkInfo.blkInfo2->blkInfoSLSize->regDataType.setNumDWorkFcn)((S), num) \\\r\n         : (0))\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetNumDWork(S, num) \\\r\n    (((S)->regDataType.setNumDWorkFcn != NULL) ? (*(S)->regDataType.setNumDWorkFcn)((S), num) : (0))\r\n#endif\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetNumDWork(S, num) ((_ssSetNumDWork(S, num)) >= -1)\r\n#endif\r\n#endif /* NOT level 1 S-function */\r\n\r\n/**\r\n * @brief ssGetNumDWork\r\n *\r\n * Get the number of data type work vectors used by a block\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @return An int_T value indicating the number of DWork vectors in this S-function.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetNumDWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDWork\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetNumDWork(S) (S)->sizes.numDWork\r\n#endif\r\n\r\n/**\r\n * @brief ssGetDWorkComplexSignal\r\n *\r\n * Determine whether the elements of a data type work vector are real or complex numbers\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return COMPLEX_YES (1) if the specified vector contains complex numbers; otherwise, COMPLEX_NO\r\n * (0).\r\n */\r\n#define ssGetDWorkComplexSignal(S, index) \\\r\n    ((S)->work.dWork.sfcn[(index)].complexSignal) /* (CSignal_T) */\r\n\r\n/**\r\n * @brief ssSetDWorkComplexSignal\r\n *\r\n * Specify whether the elements of a data type work vector are real or complex\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @param  val       Numeric type, either COMPLEX_YES or COMPLEX_NO.\r\n * @return 1 (COMPLEX_YES), 0 (COMPLEX_NO), or -1 (COMPLEX_INHERITED) depending on the value\r\n * specified by csig.\r\n */\r\n#define ssSetDWorkComplexSignal(S, index, val) (S)->work.dWork.sfcn[index].complexSignal = (val)\r\n\r\n/**\r\n * @brief ssGetDWorkDataType\r\n *\r\n * Get the data type of a data type work vector\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return The data type ID of the DWork vector specified by the index vector if the data type is\r\n * valid. Otherwise, returns INVALID_DTYPE_ID.\r\n */\r\n#define ssGetDWorkDataType(S, index) ((S)->work.dWork.sfcn[(index)].dataTypeId) /* (DTypeId) */\r\n\r\n/**\r\n * @brief ssSetDWorkDataType\r\n *\r\n * Specify the data type of a data type work vector\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @param  val       ID of a data type.\r\n * @return The data type ID specified by dtID. Returns -1 if dtID is DYNAMICALLY_TYPED.\r\n */\r\n#define ssSetDWorkDataType(S, index, val) (S)->work.dWork.sfcn[index].dataTypeId = (val)\r\n\r\n/**\r\n * @brief ssGetDWorkName\r\n *\r\n * Get the name of a data type work vector\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return A pointer (char_T *) to the character vector representing the name of the DWork vector\r\n * specified by the index vector.\r\n */\r\n#define ssGetDWorkName(S, index) ((S)->work.dWork.sfcn[(index)].name) /* (char_T *) */\r\n\r\n/**\r\n * @brief ssSetDWorkName\r\n *\r\n * Specify the name of a data type work vector\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @param  val       Name of a work vector.\r\n * @return The name of the DWork vector entered in name.\r\n */\r\n#define ssSetDWorkName(S, index, val) (S)->work.dWork.sfcn[index].name = val\r\n\r\n\r\n/**\r\n * @brief ssGetDWorkUsageType\r\n *\r\n * Determine how DWork vector is used in S-function\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return One of the enumerated types defined for ssDWorkUsageType in simstruc_types.h.\r\n */\r\n#define ssGetDWorkUsageType(S, index) (S)->work.dWork.sfcn[(index)].usedAs\r\n\r\n/**\r\n * @brief ssSetDWorkUsageType\r\n *\r\n * Specify how DWork vector is used in S-function\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @param  type      Usage type of the DWork vector.\r\n * @return The usage type entered in type\r\n */\r\n#define ssSetDWorkUsageType(S, index, val) (S)->work.dWork.sfcn[(index)].usedAs = val\r\n\r\n\r\n/**\r\n * @brief ssGetDWorkUsedAsDState\r\n *\r\n * Determine whether a data type work vector is used as a discrete state vector\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return The int_T value 1 (SS_DWORK_USED_AS_DSTATE) if this vector is used to store a block's\r\n * discrete states. Otherwise, returns 0 (SS_DWORK_USED_AS_DWORK)..\r\n */\r\n#define ssGetDWorkUsedAsDState(S, index) \\\r\n    ((S)->work.dWork.sfcn[(index)].usedAs == SS_DWORK_USED_AS_DSTATE)\r\n\r\n/**\r\n * @brief ssSetDWorkUsedAsDState\r\n *\r\n * Specify that a data type work vector is used as a discrete state vector\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @param  val       How this vector is used. A value of 1 indicates that the work vector is to be\r\n * used to store the block's discrete states (SS_DWORK_USED_AS_DSTATE), a value of 0 indicates that\r\n * the work vector is to be used as a work vector (SS_DWORK_USED_AS_DWORK).\r\n * @return 0 if usage is SS_DWORK_USED_AS_DWORK (0), otherwise returns 1.\r\n */\r\n#define ssSetDWorkUsedAsDState(S, index, val) \\\r\n    (S)->work.dWork.sfcn[(index)].usedAs =    \\\r\n        ((val) ? SS_DWORK_USED_AS_DSTATE : ((S)->work.dWork.sfcn[(index)].usedAs))\r\n\r\n\r\n\r\n/**\r\n * @brief ssGetDWorkWidth\r\n *\r\n * Get the size of a data type work vector\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return The int_T number of elements in the DWork vector specified by the index vector.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetDWorkWidth(S, index) ((S)->work.dWorkAux[(index)].widthSLSize)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetDWorkWidth(S, index) ((S)->work.dWork.sfcn[(index)].width)\r\n#endif\r\n\r\n/**\r\n * @brief ssSetDWorkWidth\r\n *\r\n * Specify the width of a data type work vector\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @param  val       Number of elements in the work vector.\r\n * @return The number of elements passed in through width.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetDWorkWidth(S, index, val) (S)->work.dWorkAux[(index)].widthSLSize = (val)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetDWorkWidth(S, index, val) (S)->work.dWork.sfcn[index].width = (val)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetDWork\r\n *\r\n * Get a DWork vector\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  index     Index of a data type work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return A pointer (void *) to the DWork vector specified by the index vector.\r\n */\r\n#define ssGetDWork(S, index) ((S)->work.dWork.sfcn[(index)].array) /*   (void *)  */\r\n\r\n/**\r\n * @brief ssGetdX\r\n *\r\n * Get the derivatives of a blocks's continuous states\r\n * @param  S         SimStruct representing an S-Function block or Simulink model.\r\n * @return A pointer (real_T *) to an array containing the derivatives of the continuous states of\r\n * S, which can be a block or the model. Returns NULL if there are no continuous states.\r\n */\r\n#define ssGetdX(S) (S)->states.dX /*   (real_T *)    */\r\n\r\n\r\n#if !SS_SFCN_LEVEL_1\r\n/**\r\n * @brief ssGetContStates\r\n *\r\n * Get a block's continuous states\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @return A pointer (real_T *) to the continuous state vector as an array of length\r\n * ssGetNumContStates(S). Returns NULL if the S-function does not have any continuous states.\r\n */\r\n#define ssGetContStates(S) (S)->states.contStates /*   (real_T *)    */\r\n/**\r\n * @brief ssGetDiscStates\r\n *\r\n * Get a block's discrete states\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @return A pointer (real_T *) to the discrete state vector as an array of length\r\n * ssGetNumDiscStates(S). Returns NULL if the S-function does not have any discrete states.\r\n */\r\n#define ssGetDiscStates(S) ((S)->states.discStates) /*   (real_T *)    */\r\n\r\n/**\r\n * @brief ssGetRealDiscStates\r\n *\r\n * Get a block's discrete state vector\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @return The discrete state vector as an array of real_T elements of length ssGetNumDiscStates(S).\r\n */\r\n#define ssGetRealDiscStates(S) ssGetDiscStates(S) /*   (real_T *)    */\r\n\r\n#endif\r\n\r\n/**\r\n * @brief ssGetNumContStates\r\n *\r\n * Get the number of continuous states that a block has\r\n * @param  S         SimStruct representing an S-Function block or Simulink model.\r\n * @return An int_T value indicating the number of continuous states.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetNumContStates(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numContStates\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetNumContStates(S) (S)->sizes.numContStates\r\n#endif\r\n\r\n/**\r\n * @brief ssSetNumContStates\r\n *\r\n * Specify the number of continuous states that a block has\r\n * @param  S            SimStruct representing an S-Function block.\r\n * @param  nContStates  Number of continuous states to be set for the block represented by S.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetNumContStates(S, nContStates) \\\r\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numContStates = (nContStates)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetNumContStates(S, nContStates) (S)->sizes.numContStates = (nContStates)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetNumDiscStates\r\n *\r\n * Get the number of discrete states that a block has\r\n * @param  S            SimStruct representing an S-Function block or a Simulink model.\r\n * @return  An int_T value indicating the number of discrete states.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetNumDiscStates(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDiscStates\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetNumDiscStates(S) (S)->sizes.numDiscStates\r\n#endif\r\n\r\n/**\r\n * @brief ssSetNumDiscStates\r\n *\r\n * Specify the number of discrete states that a block has\r\n * @param  S            SimStruct representing an S-Function block.\r\n * @param  nContStates  Number of continuous states to be set for the block represented by S.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetNumDiscStates(S, nDiscStates) \\\r\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numDiscStates = (nDiscStates)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetNumDiscStates(S, nDiscStates) (S)->sizes.numDiscStates = (nDiscStates)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetNumNonsampledZCs\r\n *\r\n * Get the size of the zero-crossing vector\r\n * @param  S            SimStruct representing an S-Function block.\r\n * @return  An int_T value indicating the size of the zero-crossing vector.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetNumNonsampledZCs(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numNonsampledZCs\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetNumNonsampledZCs(S) (S)->sizes.numNonsampledZCs\r\n#endif\r\n\r\n/**\r\n * @brief ssSetNumNonsampledZCs\r\n *\r\n * Specify the number of states for which a block detects zero crossings that occur between sample\r\n * points\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @param  nNonsampledZCs  Number of nonsampled zero crossings that a block detects.\r\n * @return The number of modes specified by nNonsampledZCs, or -1 if DYNAMICALLY_SIZED.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetNumNonsampledZCs(S, nNonsampledZCs) \\\r\n    (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numNonsampledZCs = (nNonsampledZCs)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetNumNonsampledZCs(S, nNonsampledZCs) (S)->sizes.numNonsampledZCs = (nNonsampledZCs)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetNonsampledZCs\r\n *\r\n * Get the zero-crossing signal values\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @return A pointer (real_T *) to the zero-crossing signal values.\r\n */\r\n#define ssGetNonsampledZCs(S) (S)->states.nonsampledZCs /*   (real_T *)    */\r\n\r\n\r\n/**\r\n * @brief ssGetNumRWork\r\n *\r\n * Get the size of a block's floating-point work vector\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @return An int_T value indicating the size of the RWork vector.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetNumRWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numRWork\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetNumRWork(S) (S)->sizes.numRWork\r\n#endif\r\n\r\n/**\r\n * @brief ssSetNumRWork\r\n *\r\n * Specify the size of a block's floating-point work vector\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @param  nRwork          Number of elements in the floating-point work vector.\r\n * @return The number of elements specified by nRWork, or -1 if DYNAMICALLY_SIZED.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetNumRWork(S, nRWork) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numRWork = (nRWork)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetNumRWork(S, nRWork) (S)->sizes.numRWork = (nRWork)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetRWork\r\n *\r\n * Get a block's floating-point work vector\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @return A pointer (real_T *) to the RWork vector.\r\n */\r\n#define ssGetRWork(S) (S)->work.rWork /*   (real_T *)    */\r\n\r\n\r\n\r\n#if !SS_DEBUG_FOR_SIM\r\n/**\r\n * @brief ssGetRWorkValue\r\n *\r\n * Get an element of a block's floating-point work vector\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @param  rworkIdx        Index of the element returned by this function.\r\n * @return The real_T value stored in the RWork vector element specified by the index idx.\r\n */\r\n#define ssGetRWorkValue(S, rworkIdx) (S)->work.rWork[rworkIdx] /*   (real_T)      */\r\n\r\n\r\n/**\r\n * @brief ssSetRWorkValue\r\n *\r\n * Set an element of a block's floating-point work vector\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @param  rworkIdx        Index of the element to be set.\r\n * @param  value           New value of element.\r\n * @return The real_T value passed into the macro.\r\n */\r\n#define ssSetRWorkValue(S, rworkIdx, rworkValue) (S)->work.rWork[rworkIdx] = (rworkValue)\r\n\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssGetNumIWork\r\n *\r\n * Get the size of a block's integer work vector.\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @return An int_T value indicating the size of the IWork vector.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetNumIWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numIWork\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetNumIWork(S) (S)->sizes.numIWork\r\n#endif\r\n\r\n/**\r\n * @brief ssSetNumIWork\r\n *\r\n * Specify the size of a block's integer work vector\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @param  nIWork          Number of elements in the integer work vector.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetNumIWork(S, nIWork) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numIWork = (nIWork)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetNumIWork(S, nIWork) (S)->sizes.numIWork = (nIWork)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetIWork\r\n *\r\n * Get a block's integer work vector.\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @return A pointer (int_T *) to the integer work vector for this S-function.\r\n */\r\n#define ssGetIWork(S) (S)->work.iWork /*   (int_T *)     */\r\n\r\n\r\n\r\n#if !SS_DEBUG_FOR_SIM\r\n/**\r\n * @brief ssGetIWorkValue\r\n *\r\n * Get an element of a block's integer work vector.\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  iworkIdx  Index of the element returned by this function.\r\n * @return The int_T value stored in the idx element of the integer work vector for this S-function.\r\n * Returns NULL if no value was assigned into the idx element of the IWork vector.\r\n */\r\n#define ssGetIWorkValue(S, iworkIdx) (S)->work.iWork[iworkIdx] /*   (int_T)       */\r\n\r\n/**\r\n * @brief ssSetIWorkValue\r\n *\r\n * Set an element of a block's integer work vector.\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @param  iworkIdx    Index of the element to be set.\r\n * @param  iworkValue  New value of element.\r\n * @return The int_T value passed into the macro.\r\n */\r\n#define ssSetIWorkValue(S, iworkIdx, iworkValue) (S)->work.iWork[iworkIdx] = (iworkValue)\r\n\r\n#endif\r\n\r\n\r\n/**\r\n * @brief ssGetNumPWork\r\n *\r\n * Get the size of a block's pointer work vector.\r\n * @param  S               SimStruct representing an S-Function block.\r\n * @return A int_T value indicating the size of the PWork vector.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetNumPWork(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numPWork\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetNumPWork(S) (S)->sizes.numPWork\r\n#endif\r\n\r\n/**\r\n * @brief ssSetNumPWork\r\n *\r\n * Specify the size of a block's pointer work vector.\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @param  nPWork      Number of elements to be allocated to the pointer work vector of the block\r\n * represented by S.\r\n * @return The number of elements specified by nPWork, or -1 if DYNAMICALLY_SIZED.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetNumPWork(S, nPWork) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numPWork = (nPWork)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetNumPWork(S, nPWork) (S)->sizes.numPWork = (nPWork)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetPWork\r\n *\r\n * Get a block's pointer work vector.\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @return A pointer to the PWork vector.\r\n */\r\n#define ssGetPWork(S) (S)->work.pWork /*   (void **)     */\r\n\r\n\r\n#if !SS_DEBUG_FOR_SIM\r\n\r\n/**\r\n * @brief ssGetPWorkValue\r\n *\r\n * Get a pointer from a block's pointer work vector\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @param  pworkIdx    Index of the pointer returned by this function.\r\n * @return The (void *) element of the PWork vector at the index pworkIdx.\r\n */\r\n#define ssGetPWorkValue(S, pworkIdx) (S)->work.pWork[pworkIdx] /*   (void *)      */\r\n\r\n/**\r\n * @brief ssSetPWorkValue\r\n *\r\n * Set an element of a block's pointer work vector\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @param  pworkIdx    Index of the element to be set.\r\n * @param  pworkValue  New pointer element.\r\n * @return The pointer passed into the macro.\r\n */\r\n#define ssSetPWorkValue(S, pworkIdx, pworkValue) (S)->work.pWork[pworkIdx] = (pworkValue)\r\n\r\n\r\n#endif\r\n\r\n/**\r\n * @brief ssGetNumModes\r\n *\r\n * Get the size of the mode vector\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @return An int_T value indicating the size of the mode work vector.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssGetNumModes(S) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numModes\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssGetNumModes(S) (S)->sizes.numModes /*   (int_T)       */\r\n#endif\r\n\r\n/**\r\n * @brief ssSetNumModes\r\n *\r\n * Specify the size of the block's mode vector\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  n       Size of the mode vector for the block represented by S. Valid values are 0, a\r\n * positive integer, or DYNAMICALLY_SIZED.\r\n * @return The number of modes specified by n, or -1 if DYNAMICALLY_SIZED.\r\n */\r\n#if defined(USE_64BIT_FIELDS)\r\n#define ssSetNumModes(S, n) (S)->blkInfo.blkInfo2->blkInfoSLSize->sizes.numModes = (n)\r\n#elif defined(USE_32BIT_FIELDS)\r\n#define ssSetNumModes(S, n) (S)->sizes.numModes = (n)\r\n#endif\r\n\r\n/**\r\n * @brief ssGetModeVector\r\n *\r\n * Get the mode vector\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @return A pointer (int_T *) to the mode vector.\r\n */\r\n#define ssGetModeVector(S) (S)->work.modeVector /*   (int_T *)     */\r\n\r\n/**\r\n * @brief ssGetModeVectorValue\r\n *\r\n * Get an element of a block's mode vector\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @param  idx         Index of a mode vector element.\r\n * @return An int_T value for the element of the mode vector specified by the index idx.\r\n * Returns NULL if no value was assigned into the idx element of the mode vector.\r\n */\r\n#define ssGetModeVectorValue(S, idx) (S)->work.modeVector[idx] /*   (int_T)       */\r\n\r\n\r\n/**\r\n * @brief ssSetModeVectorValue\r\n *\r\n * Set an element of a block's mode vector\r\n * @param  S           SimStruct representing an S-Function block.\r\n * @param  idx         Index of a mode vector element.\r\n * @param  val         Mode vector value.\r\n */\r\n#define ssSetModeVectorValue(S, idx, val) (S)->work.modeVector[idx] = (val)\r\n\r\n/** @} */ /* end of StateWorkVector */\r\n\r\n/** @defgroup CodeGeneration Code Generation\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Code Generation *\r\n *======================================*/\r\n/**\r\n * @brief ssGetDWorkRTWIdentifier\r\n *\r\n * Get the identifier used to declare a DWork vector in code generated from the associated\r\n * S-function\r\n * @param  S       SimStruct representing an S-Function block\r\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return A pointer (char_T *) to the character vector used as the Simulink Coder identifier for\r\n * the DWork vector specified by the index vector. Returns NULL if no Simulink Coder identifier is\r\n * specified.\r\n */\r\n#define ssGetDWorkRTWIdentifier(S, index) \\\r\n    ((S)->work.dWorkAux[(index)].rtwIdentifier) /* (char_T *) */\r\n\r\n/**\r\n * @brief ssSetDWorkRTWIdentifier\r\n *\r\n * Specify the identifier used to declare a DWork vector in code generated from the associated\r\n * S-function\r\n * @param  S       SimStruct representing an S-Function block\r\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @param  val      DWork vector identifier\r\n * @return A pointer (char_T *) to the Simulink Coder identifier entered in id.\r\n */\r\n#define ssSetDWorkRTWIdentifier(S, index, val) (S)->work.dWorkAux[index].rtwIdentifier = val\r\n\r\n/**\r\n * @brief ssGetDWorkRTWIdentifierMustResolveToSignalObject\r\n *\r\n * Get a flag indicating if a DWork vector resolves to a Simulink.Signal object\r\n * @param  S       SimStruct representing an S-Function block\r\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return A uint_T flag with the value of 0, 1, or 2.\r\n */\r\n#define ssGetDWorkRTWIdentifierMustResolveToSignalObject(S, index) \\\r\n    ((S)->work.dWorkAux[(index)].flags.rtwIdMustResolveToSignalObject)\r\n\r\n/**\r\n * @brief ssSetDWorkRTWIdentifierMustResolveToSignalObject\r\n *\r\n * Specify if a DWork vector resolves to a Simulink.Signal object\r\n * @param  S       SimStruct representing an S-Function block\r\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @param  n       Flag to control if the DWork vector resolves to a Simulink.Signal object, either\r\n * 0, 1, or 2.\r\n * @return The value for flag if flag is 0, 1, or 2. Otherwise, returns 0.\r\n */\r\n#define ssSetDWorkRTWIdentifierMustResolveToSignalObject(S, index, n) \\\r\n    (S)->work.dWorkAux[index].flags.rtwIdMustResolveToSignalObject = (n)\r\n\r\n/**\r\n * @brief ssGetDWorkRTWStorageClass\r\n *\r\n * Get the storage class of a DWork vector in code generated from the associated S-function\r\n * @param  S       SimStruct representing an S-Function block\r\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return One of the enumerated types defined for ssRTWStorageType.\r\n */\r\n#define ssGetDWorkRTWStorageClass(S, index) ((S)->work.dWorkAux[(index)].rtwStorageClass)\r\n\r\n/**\r\n * @brief ssSetDWorkRTWStorageClass\r\n *\r\n * Specify the storage class of a DWork vector in code generated from the associated S-function\r\n * @param  S       SimStruct representing an S-Function block\r\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @param  val     Storage class of the work vector. Must be one of the values enumerated by\r\n * ssRTWStorageType.\r\n * @return The ssRTWStorageType value entered as sc. Invokes an error if sc is not a valid storage\r\n * class.\r\n */\r\n#define ssSetDWorkRTWStorageClass(S, index, val) (S)->work.dWorkAux[index].rtwStorageClass = val\r\n\r\n/**\r\n * @brief ssGetDWorkRTWTypeQualifier\r\n *\r\n * Get the C type qualifier used to declare a DWork vector in code generated from the associated\r\n * S-function\r\n * @param  S       SimStruct representing an S-Function block\r\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @return A pointer (char_T *) to a character vector indicating the C type qualifier used to\r\n * declare the DWork vector specified by the index vector. Returns NULL if no type qualifier is\r\n * specified.\r\n */\r\n#define ssGetDWorkRTWTypeQualifier(S, index) ((S)->work.dWorkAux[(index)].rtwTypeQualifier)\r\n\r\n/**\r\n * @brief ssSetDWorkRTWTypeQualifier\r\n *\r\n * Specify the C type qualifier used to declare a DWork vector in code generated from the associated\r\n * S-function\r\n * @param  S       SimStruct representing an S-Function block\r\n * @param  index   Index of the work vector, where the index is one of 0, 1, 2, ...\r\n * ssGetNumDWork(S)-1.\r\n * @param  val     Type qualifier\r\n * @return The C type qualifier entered in tq.\r\n */\r\n#define ssSetDWorkRTWTypeQualifier(S, index, val) (S)->work.dWorkAux[index].rtwTypeQualifier = val\r\n\r\n\r\n/**\r\n * @brief ssGetPlacementGroup\r\n *\r\n * Get the name of the placement group of a block\r\n * @param  S       SimStruct representing an S-Function block. The block must be either a source\r\n * block (i.e., a block without input ports) or a sink block (i.e., a block without output ports).\r\n * @return A pointer (char_T *) to the character vector indicating the name of the S-function\r\n * placement group.\r\n */\r\n#define ssGetPlacementGroup(S) (S)->blkInfo.placementGroup\r\n\r\n/**\r\n * @brief ssRTWGenIsCodeGen\r\n *\r\n * Identify any code generation that is not used by the Accelerator\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @return The Boolean value true if the model is generating code for any purpose other than\r\n * Accelerator mode simulation. Returns false if the model is not generating code or is generating\r\n * code for Accelerator mode simulation.\r\n */\r\n#if SS_SIM\r\n#define ssRTWGenIsCodeGen(S)                                               \\\r\n    (ssGetSimMode(S) == SS_SIMMODE_RTWGEN &&                               \\\r\n     (((S)->mdlInfo->rtwgenMode == SS_RTWGEN_RTW_CODE) ||                  \\\r\n      ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_MODELREFERENCE_SIM_TARGET) || \\\r\n      ((S)->mdlInfo->rtwgenMode == SS_RTWGEN_MODELREFERENCE_RTW_TARGET)))\r\n#else\r\n#define ssRTWGenIsCodeGen(S) (false)\r\n#endif\r\n\r\n/**\r\n * @brief ssWriteRTW2dMatParam\r\n *\r\n * Write a matrix parameter to the model.rtw file\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  n       Parameter name.\r\n * @param  v       Parameter values.\r\n * @param  dt      DataType of parameter elements.\r\n * @param  nr      Number of rows in the matrix.\r\n * @param  nc      Number of columns in the matrix.\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\n#define ssWriteRTW2dMatParam(S, n, v, dt, nr, nc) \\\r\n    ssWriteRTWNameValuePair(S, SSWRITE_VALUE_DTYPE_2DMAT, n, v, dt, nr, nc)\r\n\r\n#if SS_SFCN_FOR_SIM\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n/**\r\n * @brief ssWriteRTWMx2dMatParam\r\n *\r\n * Write a matrix parameter in MATLAB format to the model.rtw file\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  name    Parameter name.\r\n * @param  rVal    Real elements of the parameter array.\r\n * @param  iVal    Imaginary elements of the parameter array.\r\n * @param  dtInfo  Data type of the parameter elements.\r\n * @param  nRows   Number of rows in the matrix.\r\n * @param  nCols   Number of columns in the matrix.\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\nextern int_T ssWriteRTWMx2dMatParam(SimStruct* S,\r\n                                    const char_T* name,\r\n                                    const void* rVal,\r\n                                    const void* iVal,\r\n                                    int_T dtInfo,\r\n                                    int_T nRows,\r\n                                    int_T nCols);\r\n\r\n\r\n/**\r\n * @brief ssWriteRTWMxVectParam\r\n *\r\n * Write a vector parameter in MATLAB format to the model.rtw file\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  name    Parameter name.\r\n * @param  rVal    Real elements of the parameter array.\r\n * @param  iVal    Imaginary elements of the parameter array.\r\n * @param  dtInfo  Data type of the parameter elements.\r\n * @param  numEL   Number of elements in the vector.\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\nextern int_T ssWriteRTWMxVectParam(SimStruct* S,\r\n                                   const char_T* name,\r\n                                   const void* rVal,\r\n                                   const void* iVal,\r\n                                   int_T dtInfo,\r\n                                   int_T numEl);\r\n\r\n/**\r\n * @brief ssWriteRTWParameters\r\n *\r\n * Write tunable parameter information to the model.rtw file\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  nParams Number of tunable parameters\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\nextern int_T ssWriteRTWParameters(SimStruct* S, int_T nParams, ...);\r\n\r\n/**\r\n * @brief ssWriteRTWParamSettings\r\n *\r\n * Write values of nontunable parameters to the model.rtw file\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  nParams Number of parameter settings.\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\nextern int_T ssWriteRTWParamSettings(SimStruct* S, int_T nParams, ...);\r\n\r\n\r\n/**\r\n * @brief ssWriteRTWScalarParam\r\n *\r\n * Write a scalar parameter to the model.rtw file\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  n       Parameter name.\r\n * @param  v       Parameter value.\r\n * @param  dt      Integer ID of the type of the parameter value.\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\n#define ssWriteRTWScalarParam(S, n, v, dt) \\\r\n    ssWriteRTWNameValuePair(S, SSWRITE_VALUE_DTYPE_NUM, n, v, dt)\r\n\r\n\r\n\r\n/**\r\n * @brief ssWriteRTWStr\r\n *\r\n * Write a character vector to the model.rtw file\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  str     Character vector.\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\nextern int_T ssWriteRTWStr(SimStruct* S, const char_T* str);\r\n\r\n/**\r\n * @brief ssWriteRTWStrParam\r\n *\r\n * Write a character vector parameter to the model.rtw file\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  n       Parameter name.\r\n * @param  v       Parameter value.\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\n#define ssWriteRTWStrParam(S, n, v) ssWriteRTWNameValuePair(S, SSWRITE_VALUE_QSTR, n, v)\r\n\r\n\r\n/**\r\n * @brief ssWriteRTWStrVectParam\r\n *\r\n * Write a vector of character vector parameters to the model.rtw file\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  n       Parameter name.\r\n * @param  v       Parameter value.\r\n * @param  len     Number of elements in the vector.\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\n#define ssWriteRTWStrVectParam(S, n, v, len) \\\r\n    ssWriteRTWNameValuePair(S, SSWRITE_VALUE_VECT_STR, n, v, len)\r\n\r\n/**\r\n * @brief ssWriteRTWVectParam\r\n *\r\n * Write a vector parameter to the model.rtw file\r\n * @param  S       SimStruct representing an S-Function block.\r\n * @param  n       Parameter name.\r\n * @param  v       Parameter value.\r\n * @param  dt      Data type of the parameter elements.\r\n * @param  len     Number of elements in the vector.\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\n#define ssWriteRTWVectParam(S, n, v, dt, len) \\\r\n    ssWriteRTWNameValuePair(S, SSWRITE_VALUE_DTYPE_VECT, n, v, dt, len)\r\n\r\n/**\r\n * @brief ssWriteRTWWorkVect\r\n *\r\n * Write work vectors to the model.rtw file\r\n * @param  S         SimStruct representing an S-Function block.\r\n * @param  vectName  Name of the work vector.\r\n * @param  nNames    Number of names\r\n * @return An int_T (1 or 0) or boolean_T (true or false) indicating the success or failure of the\r\n * function.\r\n */\r\nextern int_T ssWriteRTWWorkVect(SimStruct* S, const char_T* vectName, int_T nNames, ...);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n\r\n/** @} */ /* end of StateWorkVector */\r\n\r\n/** @defgroup ErrorHandling Error Handling\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Error Handling *\r\n *======================================*/\r\n\r\n/**\r\n * @brief ssPrintf\r\n *\r\n * Print a variable-content message\r\n * @param msg Must be a ANSI C printf-style character vector with optional variable replacement\r\n * parameters.\r\n * @return A positive value indicating the number of bytes transmitted. Returns a negative number\r\n * indicating an error.\r\n *\r\n * @brief ssWarning\r\n *\r\n * Display a warning message\r\n * @param S Simstruct representing an S-Function block or a Simulink model.\r\n * @param msg Warning message\r\n */\r\n#if !SS_SL_INTERNAL\r\n#if SS_SFCN_FOR_SIM\r\n\r\n#define SS_STDIO_AVAILABLE\r\n#define ssPrintf mexPrintf\r\nextern\r\n#ifdef __cplusplus\r\n    \"C\"\r\n#endif\r\n    void\r\n    ssWarning(SimStruct*, const char* msg);\r\n#elif SS_HAVESTDIO /* for Real-Time Workshop with stdio facilities */\r\n#include <stdio.h>\r\n#define SS_STDIO_AVAILABLE\r\n#define ssPrintf printf\r\n#define ssWarning(S, msg) printf(\"Warning: block '%s': %s\\n\", ssGetPath(S), msg)\r\n#else /* for Real-Time Workshop without stdio facilities */\r\nextern int rtPrintfNoOp(const char* fmt, ...);\r\n#undef SS_STDIO_AVAILABLE\r\n#define ssPrintf rtPrintfNoOp\r\n#define ssWarning(S, msg) /* do nothing */\r\n#endif\r\n#endif\r\n\r\n/**\r\n * @brief ssGetErrorStatus\r\n *\r\n * Get a character vector that identifies the last error\r\n * @param  S      SimStruct representing an S-Function block.\r\n * @return A pointer (char_T *) to a character vector that identifies the last error message.\r\n */\r\n#define ssGetErrorStatus(S) ssGetRootSS(S)->errorStatus.str /* (const char_T*) */\r\n\r\n/**\r\n * @brief ssSetErrorStatus\r\n *\r\n * report an error\r\n * @param  S       SimStruct representing an S-Function block or a Simulink model\r\n * @param  string  Error message\r\n */\r\n#define ssSetErrorStatus(S, string)                              \\\r\n    {                                                            \\\r\n        ssGetRootSS(S)->mdlInfo->mdlFlags.errorStatusIsMsg = 0U; \\\r\n        ssGetRootSS(S)->errorStatus.str = (string);              \\\r\n    }\r\n\r\n/**\r\n * @brief ssGetLocalErrorStatus\r\n *\r\n * Get a character vector that identifies the last error\r\n * @param  S      SimStruct representing an S-Function block.\r\n * @return A pointer (char_T *) to a character vector that identifies the last error message.\r\n */\r\n#define ssGetLocalErrorStatus(S) S->blkInfo.blkInfo2->localErrorStatus.str /* (const char_T*) */\r\n\r\n/**\r\n * @brief ssSetLocalErrorStatus\r\n *\r\n * report an error\r\n * @param  S       SimStruct representing an S-Function block or a Simulink model\r\n * @param  string  Error message\r\n */\r\n#define ssSetLocalErrorStatus(S, string)                          \\\r\n    {                                                             \\\r\n        (S)->blkInfo.sfcnFlags.localErrorStatusIsMsg = 0U;        \\\r\n        if (S->blkInfo.blkInfo2->localErrorStatus.str == NULL ||  \\\r\n            (const char_T*)(string) == NULL) {                    \\\r\n            S->blkInfo.blkInfo2->localErrorStatus.str = (string); \\\r\n        }                                                         \\\r\n    }\r\n\r\n/** @} */ /* end of ErrorHandling */\r\n\r\n/** @defgroup InfoOptions Information and Options\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Information and Options *\r\n *======================================*/\r\n\r\n/**\r\n * @brief ssGetModelName\r\n *\r\n * Get the model name\r\n * @param  S     SimStruct pointer\r\n * @return The name of the S-function MEX-file associated with the block if S is a SimStruct for an\r\n * S-Function block. If S is the root SimStruct, this macro returns the name of the Simulink block\r\n * diagram.\r\n */\r\n#define ssGetModelName(S) (S)->modelName /* (const char_T*) */\r\n\r\n/**\r\n * @brief ssSetOptions\r\n *\r\n * Specify S-function options\r\n * @param  S     SimStruct pointer\r\n * @param  opts  S-Function Options\r\n */\r\n#define ssSetOptions(S, opts) (S)->sizes.options = (opts)\r\n\r\n\r\n/**\r\n * @brief ssGetParentSS\r\n *\r\n * Get the parent of a SimStruct\r\n * @param  S     SimStruct pointer\r\n * @return The parent SimStruct of S, or NULL if S is the root SimStruct.\r\n */\r\n#define ssGetParentSS(S) (S)->parent /*   (SimStruct *) */\r\n\r\n/**\r\n * @brief ssGetPath\r\n *\r\n * Get the path of a block\r\n * @param  S     SimStruct representing an S-function block or a Simulink model.\r\n * @return A pointer (char_T *) to a character vector containing the path to a block.\r\n */\r\n#define ssGetPath(S) (S)->path /* (const char_T*) */\r\n\r\n/**\r\n * @brief ssGetRootSS\r\n *\r\n * Get the root of a SimStruct hierarchy\r\n * @param  S     SimStruct representing an S-function block or a Simulink model.\r\n * @return The SimStruct at the root of the SimStruct hierarchy.\r\n */\r\n#define ssGetRootSS(S) (S)->root /*   (SimStruct *) */\r\n\r\n/**\r\n * @brief ssGetUserData\r\n *\r\n * Access the user data\r\n * @param  S     SimStruct representing an S-function block.\r\n * @return A pointer (void *) to the S-function's user data\r\n */\r\n#define ssGetUserData(S) (S)->work.userData /*   (void *)      */\r\n\r\n\r\n/**\r\n * @brief ssSetPlacementGroup\r\n *\r\n * Specify the name of the placement group of a block\r\n * @param  S     SimStruct representing an S-Function block. The block must be either a source block\r\n * (i.e., a block without input ports) or a sink block (i.e., a block without output ports).\r\n * @param  name    Name of the placement group of the block represented by S.\r\n */\r\n#define ssSetPlacementGroup(S, name) (S)->blkInfo.placementGroup = (name)\r\n\r\n/**\r\n * @brief ssSetUserData\r\n *\r\n * Specify user data\r\n * @param  S     SimStruct representing an S-Function block.\r\n * @param  userDataPtr  User data\r\n */\r\n#define ssSetUserData(S, userDataPtr) (S)->work.userData = (userDataPtr)\r\n\r\n/**\r\n * @brief ssGetOwnerBlock\r\n *\r\n * Get the owner block of an S-function block\r\n * @param  S     SimStruct representing an S-Function block.\r\n */\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n#if !SS_SFCN_LEVEL_1\r\n#define ssGetOwnerBlock(S) ((S)->blkInfo.block)\r\n#endif\r\n#if !SS_SFCN\r\n#define ssSetOwnerBlock(S, block) (S)->blkInfo.block = (block)\r\n#else\r\n#define ssSetOwnerBlock(S, block) ssSetOwnerBlock_cannot_be_used_in_SFunctions\r\n#endif\r\n#endif\r\n\r\n/**\r\n * @brief ssSupportsMultipleExecInstances\r\n *\r\n * Specify that a For Each Subsystem block supports an S-function operating inside the subsystem.\r\n * @param  S      SimStruct representing an S-Function block.\r\n * @param  value  A character vector have a value of either true or false. If true, then the For\r\n * Each Subsystem will support having an S-function operate inside of it.\r\n */\r\n#if (SS_SL_INTERNAL || SS_SFCN_FOR_SIM) && defined(ssGetOwnerBlock)\r\n#define ssSupportsMultipleExecInstances(S, value)                                           \\\r\n    {                                                                                       \\\r\n        if (ssGetOwnerBlock(S) != NULL) {                                                   \\\r\n            boolean_T val = value;                                                          \\\r\n            _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SUP_MULTI_EXEC_INSTANCES, 0, &val) \\\r\n                _ssSafelyCallGenericFcnEnd;                                                 \\\r\n        }                                                                                   \\\r\n    }\r\n#else\r\n#define ssSupportsMultipleExecInstances(S, value)\r\n#endif\r\n\r\n/** @} */ /* end of InfoOptiopns */\r\n\r\n/** @defgroup SimulinkFunctionAPI S-Function API for Simulink Functions\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Simulink Function API for registering,\r\n * accessing Simulink Functions *\r\n *======================================*/\r\n\r\ntypedef enum { SS_SIMULINK_FUNCTION_QUERY_IS_DECLARED } SSSimulinkFunctionQueryType;\r\n\r\ntypedef enum { SS_SCOPED_VISIBILITY, SS_GLOBAL_VISIBILITY } SSSimulinkFunctionVisibility;\r\n\r\ntypedef struct ssFunctionQueryInfo_tag {\r\n    const char* scopedFcnName;\r\n    SSSimulinkFunctionQueryType queryType;\r\n    boolean_T queryResult;\r\n    void* reservedForFuture[4];\r\n} _ssFunctionQueryInfo;\r\n\r\ntypedef struct ssFunctionExecArguments_tag {\r\n    const char* scopedFcnName;\r\n    int numInArgs;\r\n    _ssFcnCallExecArgInfo* inArgs;\r\n    int numOutArgs;\r\n    _ssFcnCallExecArgInfo* outArgs;\r\n} _ssFunctionExecArguments;\r\n\r\ntypedef void (*SSSimulinkFunctionPtr)(SimStruct*, int, _ssFcnCallExecArgs*);\r\n\r\ntypedef struct ssFunctionAttributeInfo_tag {\r\n    const char* fcnPrototype;\r\n    SSSimulinkFunctionVisibility fcnVisibility;\r\n    SSSimulinkFunctionPtr fcnPtr;\r\n    void* reservedForFuture[4];\r\n} _ssFunctionAttributeInfo;\r\n\r\ntypedef enum {\r\n    SS_SIMULINK_FUNCTION_ARG_DIMS,\r\n    SS_SIMULINK_FUNCTION_ARG_DTYPE,\r\n    SS_SIMULINK_FUNCTION_ARG_CPLX\r\n} SSFunctionArgAttributeType;\r\n\r\ntypedef struct ssFunctionArgAttributeInfo_tag {\r\n    const char* scopedFcnName;\r\n    const char* argName;\r\n    int argDT;\r\n    int argNumDims;\r\n    size_t* argDims;\r\n    int argCplx;\r\n    SSFunctionArgAttributeType argAttrToSet;\r\n    void* reservedForFuture[4];\r\n} _ssFunctionArgAttributeInfo;\r\n\r\n#if SS_SFCN && SS_SIM\r\n/*\r\n * Note that in ssQuerySimulinkFunction, there is an extra () around the macro\r\n * definition, and this is to allow returning a boolean result for the query.\r\n */\r\n\r\n/**\r\n * @brief ssQuerySimulinkFunction\r\n *\r\n * @param  S         SimStruct representing an S-Function block\r\n * @param scopedName Name of function being queried.\r\n * @param query      Enumeration of type SSSimulinkFunctionQueryType\r\n * @return           Boolean result of query\r\n */\r\n#define ssQuerySimulinkFunction(S, scopedName, query)                                           \\\r\n    ({                                                                                          \\\r\n        _ssFunctionQueryInfo locQueryInfo;                                                      \\\r\n        locQueryInfo.scopedFcnName = scopedName;                                                \\\r\n        locQueryInfo.queryType = query;                                                         \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_QUERY_SIMULINK_FUNCTION, 0, &locQueryInfo) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                         \\\r\n        locQueryInfo.queryResult;                                                               \\\r\n    })\r\n\r\n/**\r\n * @brief ssDeclareSimulinkFunction\r\n *\r\n * Declares either a global or scoped function\r\n * @param  S     SimStruct representing an S-Function block\r\n * @param proto  Prototype of function being declared.\r\n * @param ptr    Pointer to C function\r\n * @param vis    Visibility of function\r\n */\r\n#define ssDeclareSimulinkFunction(S, proto, ptr, vis)                                            \\\r\n    {                                                                                            \\\r\n        _ssFunctionAttributeInfo locAttrInfo;                                                    \\\r\n        locAttrInfo.fcnPrototype = proto;                                                        \\\r\n        locAttrInfo.fcnVisibility = vis;                                                         \\\r\n        locAttrInfo.fcnPtr = ptr;                                                                \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_DECLARE_SIMULINK_FUNCTION, 0, &locAttrInfo) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                          \\\r\n    }\r\n\r\n/**\r\n * @brief ssDeclareFunctionCaller\r\n *\r\n * @param  S     SimStruct representing an S-Function block\r\n * @param  proto Prototype of function that will be called\r\n */\r\n#define ssDeclareFunctionCaller(S, proto)                                                        \\\r\n    {                                                                                            \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_DECLARE_SIMULINK_FUNCTION_CALLER, 0, proto) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                          \\\r\n    }\r\n\r\n/**\r\n * @brief ssCallSimulinkFunction\r\n *\r\n * @param  S            SimStruct representing an S-Function block\r\n * @param  scopedName   Scoped name of called function\r\n * @param  nArgin       Number of input arguments\r\n * @param  argins       Array of void * pointer to input arguments\r\n * @param  nArgout      Number of output arguments\r\n * @param  argouts      Array of void * pointer to output arguments\r\n */\r\n#define ssCallSimulinkFunction(S, scopedName, nArgin, argins, nArgout, argouts)               \\\r\n    {                                                                                         \\\r\n        _ssFunctionExecArguments locExecArgs;                                                 \\\r\n        locExecArgs.scopedFcnName = scopedName;                                               \\\r\n        locExecArgs.numInArgs = nArgin;                                                       \\\r\n        locExecArgs.inArgs = argins;                                                          \\\r\n        locExecArgs.numOutArgs = nArgout;                                                     \\\r\n        locExecArgs.outArgs = argouts;                                                        \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_CALL_SIMULINK_FUNCTION, 0, &locExecArgs) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                       \\\r\n    }\r\n\r\n/**\r\n * @brief ssGetSimulinkFunctionInput\r\n *\r\n * @param args  Pointer to arguments passed to called C function\r\n * @param idx   Index of input argument\r\n */\r\n#define ssGetSimulinkFunctionInput(args, idx) ((args)->inArgs[(idx)].dataPtr)\r\n\r\n/**\r\n * @brief ssGetSimulinkFunctionOutput\r\n *\r\n * @param args  Pointer to arguments passed to called C function\r\n * @param idx   Index of output argument\r\n */\r\n#define ssGetSimulinkFunctionOutput(args, idx) ((args)->outArgs[(idx)].dataPtr)\r\n\r\n/**\r\n * @brief ssSetSimulinkFunctionArgComplexity\r\n *\r\n * @param  S          SimStruct representing an S-Function block\r\n * @param scopedName  Name of function (or scoped name when the function is being called)\r\n * @param arg         Name of argument\r\n * @param val         Complexity of argument\r\n */\r\n#define ssSetSimulinkFunctionArgComplexity(S, scopedName, arg, val)                               \\\r\n    {                                                                                             \\\r\n        _ssFunctionArgAttributeInfo locAttrInfo;                                                  \\\r\n        locAttrInfo.scopedFcnName = scopedName;                                                   \\\r\n        locAttrInfo.argName = arg;                                                                \\\r\n        locAttrInfo.argCplx = (int)val;                                                           \\\r\n        locAttrInfo.argAttrToSet = SS_SIMULINK_FUNCTION_ARG_CPLX;                                 \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SIMULINK_FUNCTION_ARGUMENT, 0, &locAttrInfo) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                           \\\r\n    }\r\n\r\n/**\r\n * @brief ssSetSimulinkFunctionArgDataType\r\n *\r\n * @param  S     SimStruct representing an S-Function block\r\n * @param scopedName  Name of function (or scoped name when the function is being called)\r\n * @param arg         Name of argument\r\n * @param val         Data type of argument\r\n */\r\n#define ssSetSimulinkFunctionArgDataType(S, scopedName, arg, val)                                 \\\r\n    {                                                                                             \\\r\n        _ssFunctionArgAttributeInfo locAttrInfo;                                                  \\\r\n        locAttrInfo.scopedFcnName = scopedName;                                                   \\\r\n        locAttrInfo.argName = arg;                                                                \\\r\n        locAttrInfo.argDT = (int)val;                                                             \\\r\n        locAttrInfo.argAttrToSet = SS_SIMULINK_FUNCTION_ARG_DTYPE;                                \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SIMULINK_FUNCTION_ARGUMENT, 0, &locAttrInfo) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                           \\\r\n    }\r\n\r\n/**\r\n * @brief ssSetSimulinkFunctionArgDimensions\r\n *\r\n * @param  S          SimStruct representing an S-Function block\r\n * @param scopedName  Name of function (or scoped name when the function is being called)\r\n * @param arg         Name of argument\r\n * @param nDims       Number of dimensions of argument\r\n * @param val         Integer array of dimensions.\r\n */\r\n#define ssSetSimulinkFunctionArgDimensions(S, scopedName, arg, nDims, val)                        \\\r\n    {                                                                                             \\\r\n        _ssFunctionArgAttributeInfo locAttrInfo;                                                  \\\r\n        locAttrInfo.scopedFcnName = scopedName;                                                   \\\r\n        locAttrInfo.argName = arg;                                                                \\\r\n        locAttrInfo.argNumDims = nDims;                                                           \\\r\n        locAttrInfo.argDims = (size_t*)val;                                                       \\\r\n        locAttrInfo.argAttrToSet = SS_SIMULINK_FUNCTION_ARG_DIMS;                                 \\\r\n        _ssSafelyCallGenericFcnStart(S)((S), GEN_FCN_SIMULINK_FUNCTION_ARGUMENT, 0, &locAttrInfo) \\\r\n            _ssSafelyCallGenericFcnEnd;                                                           \\\r\n    }\r\n#endif\r\n\r\n/**\r\n * @brief ssSetArrayLayoutForCodeGen\r\n *\r\n * @param S         SimStruct representing an S-Function block\r\n * @param majority  Type of the array layout configuration of the S-Function TLC\r\n */\r\n#define ssSetArrayLayoutForCodeGen(S, majority) \\\r\n    (S)->blkInfo.sfcnFlags.sCodeGenArrayLayout = (majority)\r\n\r\n/** @} */ /* end of SFunctionAPI */\r\n\r\n/** @defgroup SigRegion Signal Region APIs\r\n *  @{\r\n */\r\n\r\n/*======================================*\r\n * Signal Region                        *\r\n *======================================*/\r\n#if SS_SL_INTERNAL || SS_SFCN_FOR_SIM\r\n\r\n/**\r\n * @brief ssCallSelectedSignalsFcn\r\n *\r\n * Get a list of selected output ports in the current graph.  These ports may be used\r\n * in ssCallSigListCreateFcn to access the data for these ports.\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param voidBlock        S-Function block (see ssGetOwnerBlock)\r\n * @param sigSetOpt        SIGSET_GRAPH or SIGSET_GRAPH_N_CHILDREN\r\n * @param voidOutPortObjs  Array of port objects;  free using ssCallGenericDestroyFcn\r\n * @param outnPortObjs     Number of ports returned\r\n */\r\n#define ssCallSelectedSignalsFcn(S, voidBlock, sigSetOpt, voidOutPortObjs, outnPortObjs)     \\\r\n    (S)->mdlInfo->signalAccess->SelectedSignals((voidBlock), (sigSetOpt), (voidOutPortObjs), \\\r\n                                                (outnPortObjs))\r\n\r\n/**\r\n * @brief ssCallGenericDestroyFcn\r\n *\r\n * Free a Free a port list obtained from ssCallSelectedSignalsFcn\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param ptr              Port list to destroy\r\n */\r\n#define ssCallGenericDestroyFcn(S, ptr) (S)->mdlInfo->signalAccess->utFree((ptr))\r\n\r\n/**\r\n * @brief ssCallSigListCreateFcn\r\n *\r\n * Get the \"signal list\" for a given set of ports.  This is used to access data for\r\n * the given signals\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param voidBlock        S-Function (see ssGetOwnerBlock)\r\n * @param nPorts           Number of ports in voidPortObjs\r\n * @param voidPortObjs     Array of port objects from ssCallSelectedSignalsFcn\r\n * @param excludeFlags     Options of what to exclude\r\n * @param voidOutSigList   SL_SigList returned; free using ssCallSigListDestroyFcn\r\n */\r\n#define ssCallSigListCreateFcn(S, voidBlock, nPorts, voidPortObjs, excludeFlags, voidOutSigList) \\\r\n    (S)->mdlInfo->signalAccess->SigListCreate((voidBlock), (nPorts), (voidPortObjs),             \\\r\n                                              (excludeFlags), (voidOutSigList))\r\n\r\n/**\r\n * @brief ssCallSigListDestroyFcn\r\n *\r\n * Free a SL_SigList created from ssCallSigListCreateFcn\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param voidSigList      SL_SigList to destroy\r\n */\r\n#define ssCallSigListDestroyFcn(S, voidSigList) \\\r\n    (S)->mdlInfo->signalAccess->SigListDestroy((voidSigList))\r\n\r\n/**\r\n * @brief ssCallSigListUnavailSigAlertFcn\r\n *\r\n * Report an error if any signals in the signal list are not available\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param voidSigList      SL_SigList\r\n */\r\n#define ssCallSigListUnavailSigAlertFcn(S, voidSigList) \\\r\n    (S)->mdlInfo->signalAccess->SigListUnavailSigAlert((voidSigList))\r\n\r\n/**\r\n * @brief ssCallUnselectSigFcn\r\n *\r\n * Un-select a given port from the signal list\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param voidPortObj      Port pointer from ssCallSelectedSignalsFcn\r\n */\r\n#define ssCallUnselectSigFcn(S, voidPortObj) (S)->mdlInfo->signalAccess->UnselectSig((voidPortObj))\r\n\r\n/**\r\n * @brief ssCallGetPortNameFcn\r\n *\r\n * Get the name for a given port. Returns a const char *\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param voidPortObj      Port pointer from ssCallSelectedSignalsFcn\r\n */\r\n#define ssCallGetPortNameFcn(S, voidPortObj) (S)->mdlInfo->signalAccess->GetPortName((voidPortObj))\r\n\r\n/**\r\n * @brief ssCallSigListGetNumRegionsFcn\r\n *\r\n * Get the number of regions in the idx-th element of the signal list.\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param voidSigList      SL_SigList\r\n * @param idx              Index within the signal list\r\n */\r\n#define ssCallSigListGetNumRegionsFcn(S, voidSigList, idx) \\\r\n    (S)->mdlInfo->signalAccess->SigListGetNumRegions((voidSigList), (idx))\r\n\r\n/**\r\n * @brief ssCallSigListGetFirstRegFcn\r\n *\r\n * Get the first signal region of the idx-th element of the signal list.\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param voidSigList      SL_SigList\r\n * @param idx              Index within the signal list\r\n */\r\n#define ssCallSigListGetFirstRegFcn(S, voidSigList, idx) \\\r\n    (S)->mdlInfo->signalAccess->SigListGetFirstReg((voidSigList), (idx))\r\n\r\n/**\r\n * @brief ssCallSigListGetNumElementsFcn\r\n *\r\n * Get the total number of elements in the idx-th element of the signal list.\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param voidSigList      SL_SigList\r\n * @param idx              Index within the signal list\r\n */\r\n#define ssCallSigListGetNumElementsFcn(S, voidSigList, idx) \\\r\n    (S)->mdlInfo->signalAccess->SigListGetNumElements((voidSigList), (idx))\r\n\r\n/**\r\n * @brief ssCallSigListGetIfTieWrapFcn\r\n *\r\n * Return true if the idx-th element of the signal list is a \"tie wrap\"\r\n *\r\n * @param S                SimStruct representing an S-Function block\r\n * @param voidSigList      SL_SigList\r\n * @param idx              Index within the signal list\r\n */\r\n#define ssCallSigListGetIfTieWrapFcn(S, voidSigList, idx) \\\r\n    (S)->mdlInfo->signalAccess->SigListGetIfTieWrap((voidSigList), (idx))\r\n\r\n#endif\r\n/** @} */ /* end of SigRegion */\r\n\r\n# define ssSetSimStruct(S, srcS) \\\r\n    (S)->work.localMdlInfo->simStruct = ((void*) (srcS))\r\n\r\n# define ssGetSimStruct(S) \\\r\n    (S)->work.localMdlInfo->simStruct\r\n\r\n#ifndef USE_PUBLISHED_ONLY\r\n#include \"simstruc_internal.h\"\r\n#else\r\n#include \"simstruc_implement.h\"\r\n#endif\r\n\r\n#endif /* __SIMSTRUC__ */\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic pop\r\n#endif\r\n\r\n/* EOF: simstruc.h */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};